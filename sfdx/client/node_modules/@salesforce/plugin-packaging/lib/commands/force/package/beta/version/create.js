"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageVersionCreateCommand = void 0;
const os = require("os");
const path = require("path");
const fs = require("fs");
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const packaging_1 = require("@salesforce/packaging");
var Package2VersionStatus = packaging_1.PackagingSObjects.Package2VersionStatus;
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_version_create');
class PackageVersionCreateCommand extends command_1.SfdxCommand {
    async run() {
        if (this.flags.skipvalidation) {
            this.ux.warn(messages.getMessage('skipValidationWarning'));
        }
        const frequency = this.flags.wait && this.flags.skipvalidation ? kit_1.Duration.seconds(5) : kit_1.Duration.seconds(30);
        // no async methods
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('in-progress', async (data) => {
            if (data.Status !== Package2VersionStatus.success && data.Status !== Package2VersionStatus.error) {
                this.ux.setSpinnerStatus(messages.getMessage('packageVersionCreateWaitingStatus', [data.remainingWaitTime.minutes, data.Status]));
            }
        });
        core_1.Lifecycle.getInstance().on('packageVersionCreate:preserveFiles', 
        // eslint-disable-next-line @typescript-eslint/require-await
        async (data) => {
            this.ux.log(messages.getMessage('tempFileLocation', [data.location]));
        });
        // resolve the package id from the --package flag, first checking if it's an alias, then using the flag (an id), and then looking for the package name from the --path flag
        let packageName;
        if (this.flags.package) {
            // we're unable to type this earlier, because casting `undefined as string` will result in "", which would screw up the logic below
            const pkg = this.flags.package;
            packageName = pkg.startsWith('0ho') ? pkg : (0, packaging_1.getPackageIdFromAlias)(pkg, this.project);
        }
        else {
            // due to flag validation, we'll either have a package or path flag
            packageName = this.project.getPackageFromPath(this.flags.path).package;
        }
        const packageId = (0, packaging_1.getPackageIdFromAlias)(packageName, this.project);
        const pv = new packaging_1.PackageVersion({ project: this.project, connection: this.hubOrg.getConnection() });
        this.ux.startSpinner(messages.getMessage('requestInProgress'));
        const result = await pv.create({ ...this.flags, ...{ packageId } }, {
            timeout: this.flags.wait,
            frequency,
        });
        this.ux.stopSpinner(messages.getMessage('packageVersionCreateFinalStatus', [result.Status]));
        switch (result.Status) {
            case 'Error':
                throw messages.createError('unknownError', [result.Error.join('\n')]);
            case 'Success':
                this.ux.log(messages.getMessage(result.Status, [
                    result.Id,
                    result.SubscriberPackageVersionId,
                    packaging_1.INSTALL_URL_BASE.toString(),
                    result.SubscriberPackageVersionId,
                ]));
                break;
            default:
                this.ux.log(messages.getMessage('InProgress', [(0, packaging_1.convertCamelCaseStringToSentence)(result.Status), result.Id]));
        }
        return result;
    }
}
exports.PackageVersionCreateCommand = PackageVersionCreateCommand;
PackageVersionCreateCommand.description = messages.getMessage('cliDescription');
PackageVersionCreateCommand.examples = messages.getMessage('examples').split(os.EOL);
PackageVersionCreateCommand.requiresDevhubUsername = true;
PackageVersionCreateCommand.requiresProject = true;
PackageVersionCreateCommand.flagsConfig = {
    branch: command_1.flags.string({
        char: 'b',
        description: messages.getMessage('branch'),
        longDescription: messages.getMessage('longBranch'),
    }),
    buildinstance: command_1.flags.string({
        char: 's',
        description: messages.getMessage('instance'),
        longDescription: messages.getMessage('longInstance'),
        hidden: true,
    }),
    codecoverage: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('codeCoverage'),
        longDescription: messages.getMessage('longCodeCoverage'),
        default: false,
        exclusive: ['skipvalidation'],
    }),
    definitionfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('definitionfile'),
        longDescription: messages.getMessage('longDefinitionfile'),
    }),
    installationkey: command_1.flags.string({
        char: 'k',
        description: messages.getMessage('key'),
        longDescription: messages.getMessage('longKey'),
        exactlyOne: ['installationkey', 'installationkeybypass'],
    }),
    installationkeybypass: command_1.flags.boolean({
        char: 'x',
        description: messages.getMessage('keyBypass'),
        longDescription: messages.getMessage('longKeyBypass'),
        exactlyOne: ['installationkey', 'installationkeybypass'],
    }),
    package: command_1.flags.string({
        char: 'p',
        description: messages.getMessage('package'),
        longDescription: messages.getMessage('longPackage', []),
        exactlyOne: ['path', 'package'],
    }),
    path: command_1.flags.directory({
        char: 'd',
        description: messages.getMessage('path'),
        longDescription: messages.getMessage('longPath'),
        exactlyOne: ['path', 'package'],
        validate: (dir) => {
            if (!fs.existsSync(path.join(process.cwd(), dir))) {
                throw messages.createError('errorPathNotFound', [dir]);
            }
            return true;
        },
    }),
    postinstallscript: command_1.flags.string({
        description: messages.getMessage('postInstallScript'),
        longDescription: messages.getMessage('postInstallScriptLong'),
    }),
    postinstallurl: command_1.flags.url({
        description: messages.getMessage('postInstallUrl'),
        longDescription: messages.getMessage('postInstallUrlLong'),
    }),
    preserve: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('preserve'),
        longDescription: messages.getMessage('longPreserve'),
        hidden: true,
    }),
    releasenotesurl: command_1.flags.url({
        description: messages.getMessage('releaseNotesUrl'),
        longDescription: messages.getMessage('releaseNotesUrlLong'),
    }),
    skipancestorcheck: command_1.flags.boolean({
        description: messages.getMessage('skipAncestorCheck'),
        longDescription: messages.getMessage('skipAncestorCheckLong'),
        default: false,
    }),
    skipvalidation: command_1.flags.boolean({
        description: messages.getMessage('skipValidation'),
        longDescription: messages.getMessage('skipValidationLong'),
        default: false,
        exclusive: ['codecoverage'],
    }),
    tag: command_1.flags.string({
        char: 't',
        description: messages.getMessage('tag'),
        longDescription: messages.getMessage('longTag'),
    }),
    uninstallscript: command_1.flags.string({
        description: messages.getMessage('uninstallScript'),
        longDescription: messages.getMessage('uninstallScriptLong'),
    }),
    validateschema: command_1.flags.boolean({
        char: 'j',
        description: messages.getMessage('validateschema'),
        longDescription: messages.getMessage('longValidateschema'),
        hidden: true,
    }),
    versiondescription: command_1.flags.string({
        char: 'e',
        description: messages.getMessage('versiondescription'),
        longDescription: messages.getMessage('longVersiondescription'),
    }),
    versionname: command_1.flags.string({
        char: 'a',
        description: messages.getMessage('versionname'),
        longDescription: messages.getMessage('longVersionname'),
    }),
    versionnumber: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('versionnumber'),
        longDescription: messages.getMessage('longVersionnumber'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('wait'),
        longDescription: messages.getMessage('longWait'),
        default: kit_1.Duration.minutes(0),
    }),
};
//# sourceMappingURL=create.js.map