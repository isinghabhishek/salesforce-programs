"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Install = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const packaging_1 = require("@salesforce/packaging");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_install');
// maps of command flag values to PackageInstallRequest values
const securityType = { AllUsers: 'full', AdminsOnly: 'none' };
const upgradeType = { Delete: 'delete-only', DeprecateOnly: 'deprecate-only', Mixed: 'mixed-mode' };
class Install extends command_1.SfdxCommand {
    async run() {
        const noPrompt = this.flags.noprompt;
        this.connection = this.org.getConnection();
        this.pkg = new packaging_1.Package({ connection: this.connection });
        const apiVersion = parseInt(this.connection.getApiVersion(), 10);
        if (apiVersion < 36) {
            throw messages.createError('apiVersionTooLow');
        }
        const request = {
            SubscriberPackageVersionKey: this.resolveSubscriberPackageVersionKey(this.flags.package),
            Password: this.flags.installationkey,
            ApexCompileType: this.flags.apexcompile,
            SecurityType: securityType[this.flags.securitytype],
            UpgradeType: upgradeType[this.flags.upgradetype],
        };
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('PackageInstallRequest:warning', async (warningMsg) => {
            this.ux.log(warningMsg);
        });
        // If the user has specified --upgradetype Delete, then prompt for confirmation
        // unless the noprompt option has been included.
        if (this.flags.upgradetype === 'Delete') {
            await this.confirmUpgradeType(request, noPrompt);
        }
        // If the package has external sites, ask the user for permission to enable them
        // unless the noprompt option has been included.
        await this.confirmExternalSites(request, noPrompt);
        if (this.flags.publishwait) {
            await this.waitForPublish(request);
        }
        let installOptions;
        if (this.flags.wait) {
            installOptions = {
                pollingTimeout: this.flags.wait,
            };
            let remainingTime = this.flags.wait;
            let timeThen = Date.now();
            this.ux.startSpinner(messages.getMessage('packageInstallWaiting', [remainingTime.minutes]));
            // eslint-disable-next-line @typescript-eslint/require-await
            core_1.Lifecycle.getInstance().on('PackageInstallRequest:status', async (piRequest) => {
                const elapsedTime = kit_1.Duration.milliseconds(Date.now() - timeThen);
                timeThen = Date.now();
                remainingTime = kit_1.Duration.milliseconds(remainingTime.milliseconds - elapsedTime.milliseconds);
                this.ux.setSpinnerStatus(messages.getMessage('packageInstallWaitingStatus', [remainingTime.minutes, piRequest.Status]));
            });
        }
        const pkgInstallRequest = await this.pkg.install(request, installOptions);
        const { Status } = pkgInstallRequest;
        this.ux.stopSpinner();
        if (Status === 'SUCCESS') {
            this.ux.log(messages.getMessage('packageInstallSuccess', [this.flags.package]));
        }
        else if (['IN_PROGRESS', 'UNKNOWN'].includes(Status)) {
            this.ux.log(messages.getMessage('packageInstallInProgress', [pkgInstallRequest.Id, this.org.getUsername()]));
        }
        else {
            throw messages.createError('packageInstallError', [this.parseInstallErrors(pkgInstallRequest)]);
        }
        return pkgInstallRequest;
    }
    async finally(err) {
        // Remove all the event listeners or they will still handle events
        core_1.Lifecycle.getInstance().removeAllListeners('PackageInstallRequest:warning');
        core_1.Lifecycle.getInstance().removeAllListeners('PackageInstallRequest:status');
        core_1.Lifecycle.getInstance().removeAllListeners('SubscriberPackageVersion:status');
        await super.finally(err);
    }
    async confirmUpgradeType(request, noPrompt) {
        const pkgType = await (0, packaging_1.getPackageTypeBy04t)(request.SubscriberPackageVersionKey, this.connection, request.Password);
        if (pkgType === 'Unlocked' && !noPrompt) {
            const promptMsg = messages.getMessage('promptUpgradeType');
            if (!(await this.ux.confirm(promptMsg))) {
                throw messages.createError('promptUpgradeTypeDeny');
            }
        }
    }
    async confirmExternalSites(request, noPrompt) {
        const extSites = await this.pkg.getExternalSites(request.SubscriberPackageVersionKey, request.Password);
        if (extSites) {
            let enableRss = true;
            if (!noPrompt) {
                const promptMsg = messages.getMessage('promptEnableRss', [extSites.join('\n')]);
                enableRss = await this.ux.confirm(promptMsg);
            }
            if (enableRss) {
                request.EnableRss = enableRss;
            }
        }
    }
    async waitForPublish(request) {
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('SubscriberPackageVersion:status', async (status) => {
            const tokens = status ? [` Status = ${status}`] : [];
            this.ux.log(messages.getMessage('publishWaitProgress', tokens));
        });
        // wait for the Subscriber Package Version ID to become available in the target org
        try {
            await this.pkg.waitForPublish(request.SubscriberPackageVersionKey, this.flags.publishwait);
        }
        catch (err) {
            const error = err instanceof core_1.SfError ? err : core_1.SfError.wrap(err);
            // If an uninstall is in progress, allow install to proceed which will result in an
            // appropriate UninstallInProgressProblem error message being displayed.
            const queryResult = error.data;
            if (queryResult) {
                const pkgVersion = queryResult.records[0];
                if (pkgVersion.InstallValidationStatus !== 'UNINSTALL_IN_PROGRESS') {
                    throw error;
                }
            }
            else {
                throw error;
            }
        }
    }
    parseInstallErrors(request) {
        var _a;
        const errors = (_a = request === null || request === void 0 ? void 0 : request.Errors) === null || _a === void 0 ? void 0 : _a.errors;
        if (errors === null || errors === void 0 ? void 0 : errors.length) {
            let errorMessage = 'Installation errors: ';
            for (let i = 0; i < errors.length; i++) {
                errorMessage += `\n${i + 1}) ${errors[i].message}`;
            }
            return errorMessage;
        }
        return '<empty>';
    }
    // Given a package version ID (04t) or an alias for the package, validate and
    // return the package version ID (aka SubscriberPackageVersionKey).
    resolveSubscriberPackageVersionKey(idOrAlias) {
        var _a;
        let resolvedId;
        if (idOrAlias.startsWith('04t')) {
            packaging_1.Package.validateId(idOrAlias, 'SubscriberPackageVersionId');
            resolvedId = idOrAlias;
        }
        else {
            let packageAliases;
            try {
                const projectJson = core_1.SfProject.getInstance().getSfProjectJson();
                packageAliases = (_a = projectJson.getContents().packageAliases) !== null && _a !== void 0 ? _a : {};
            }
            catch (e) {
                throw messages.createError('projectNotFound', [idOrAlias]);
            }
            resolvedId = packageAliases[idOrAlias];
            if (!resolvedId) {
                throw messages.createError('packageAliasNotFound', [idOrAlias]);
            }
            packaging_1.Package.validateId(resolvedId, 'SubscriberPackageVersionId');
        }
        return resolvedId;
    }
}
exports.Install = Install;
Install.description = messages.getMessage('cliDescription');
Install.examples = messages.getMessage('examples').split(os.EOL);
Install.requiresUsername = true;
Install.flagsConfig = {
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('wait'),
        longDescription: messages.getMessage('waitLong'),
    }),
    installationkey: command_1.flags.string({
        char: 'k',
        description: messages.getMessage('installationKey'),
        longDescription: messages.getMessage('installationKeyLong'),
    }),
    publishwait: command_1.flags.minutes({
        char: 'b',
        description: messages.getMessage('publishWait'),
        longDescription: messages.getMessage('publishWaitLong'),
    }),
    noprompt: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('noPrompt'),
        longDescription: messages.getMessage('noPromptLong'),
    }),
    package: command_1.flags.string({
        char: 'p',
        description: messages.getMessage('package'),
        longDescription: messages.getMessage('packageLong'),
        required: true,
    }),
    apexcompile: command_1.flags.enum({
        char: 'a',
        description: messages.getMessage('apexCompile'),
        longDescription: messages.getMessage('apexCompileLong'),
        default: 'all',
        options: ['all', 'package'],
    }),
    securitytype: command_1.flags.enum({
        char: 's',
        description: messages.getMessage('securityType'),
        longDescription: messages.getMessage('securityTypeLong'),
        default: 'AdminsOnly',
        options: ['AllUsers', 'AdminsOnly'],
    }),
    upgradetype: command_1.flags.enum({
        char: 't',
        description: messages.getMessage('upgradeType'),
        longDescription: messages.getMessage('upgradeTypeLong'),
        default: 'Mixed',
        options: ['DeprecateOnly', 'Mixed', 'Delete'],
    }),
};
//# sourceMappingURL=install.js.map