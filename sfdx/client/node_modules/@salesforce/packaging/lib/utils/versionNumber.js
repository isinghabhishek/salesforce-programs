"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionNumber = exports.BuildNumberToken = void 0;
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'messages');
var BuildNumberToken;
(function (BuildNumberToken) {
    BuildNumberToken["LATEST_BUILD_NUMBER_TOKEN"] = "LATEST";
    BuildNumberToken["NEXT_BUILD_NUMBER_TOKEN"] = "NEXT";
    BuildNumberToken["RELEASED_BUILD_NUMBER_TOKEN"] = "RELEASED";
    BuildNumberToken["HIGHEST_VERSION_NUMBER_TOKEN"] = "HIGHEST";
    BuildNumberToken["NONE_VERSION_NUMBER_TOKEN"] = "NONE";
})(BuildNumberToken = exports.BuildNumberToken || (exports.BuildNumberToken = {}));
class VersionNumber {
    constructor(major, minor, patch, build) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
        this.build = build;
    }
    static from(versionString) {
        if (!versionString) {
            throw messages.createError('errorMissingVersionNumber');
        }
        const version = versionString.split('.');
        if (version?.length === 4) {
            const [major, minor, patch, build] = version;
            const asNumbers = [major, minor, patch, build].map((v) => parseInt(v, 10));
            if (asNumbers.slice(0, 3).some((v) => isNaN(v))) {
                throw messages.createError('errorInvalidMajorMinorPatchNumber', [versionString]);
            }
            if (isNaN(asNumbers[3]) && !Object.values(BuildNumberToken).includes(build)) {
                throw messages.createError('errorInvalidBuildNumberToken', [
                    versionString,
                    Object.values(BuildNumberToken).join(', '),
                ]);
            }
            return new VersionNumber(major, minor, patch, build);
        }
        throw messages.createError('errorInvalidVersionNumber', [versionString]);
    }
    toString() {
        {
            return `${this.major || '0'}.${this.minor || '0'}.${this.patch || '0'}.${this.build ? `${this.build}` : '0'}`;
        }
    }
    isbuildKeyword() {
        return Object.values(BuildNumberToken)
            .map((v) => v.toString())
            .includes(this.build.toLowerCase());
    }
}
exports.VersionNumber = VersionNumber;
//# sourceMappingURL=versionNumber.js.map