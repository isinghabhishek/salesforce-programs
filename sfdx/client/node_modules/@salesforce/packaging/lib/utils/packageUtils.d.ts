import { Connection, NamedPackageDir, PackageDir, SfdcUrl, SfError, SfProject } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
import { Many, Nullable } from '@salesforce/ts-types';
import { SaveError } from 'jsforce';
import { PackageDescriptorJson, PackageType, PackageVersionCreateRequestResult, PackagingSObjects } from '../interfaces';
export declare const VERSION_NUMBER_SEP = ".";
export declare type IdRegistryValue = {
    prefix: string;
    label: string;
};
export declare type IdRegistry = {
    [key: string]: IdRegistryValue;
};
export declare const INSTALL_URL_BASE: SfdcUrl;
export declare const SOQL_WHERE_CLAUSE_MAX_LENGTH = 4000;
export declare const POLL_INTERVAL_SECONDS = 30;
export declare const DEFAULT_PACKAGE_DIR: {
    path: string;
    package: string;
    versionName: string;
    versionNumber: string;
    default: boolean;
};
export declare const BY_PREFIX: IdRegistry;
export declare const BY_LABEL: IdRegistry;
export declare function validateId(idObj: Many<IdRegistryValue>, value: string): void;
export declare function validateIdNoThrow(idObj: Many<IdRegistryValue>, value: any): IdRegistryValue | false;
export declare function validateVersionNumber(versionNumberString: string, supportedBuildNumberToken: string, supportedBuildNumberToken2?: string): string;
export declare function validatePatchVersion(connection: Connection, versionNumberString: string, packageId: string): Promise<void>;
export declare function isErrorFromSPVQueryRestriction(err: Error): boolean;
export declare function isErrorPackageNotAvailable(err: Error): boolean;
export declare function massageErrorMessage(err: Error): Error;
export declare function applyErrorAction(err: Error): Error;
/**
 * Given a subscriber package version ID (04t) or package version ID (05i), return the package version ID (05i)
 *
 * @param versionId The subscriber package version ID
 * @param connection For tooling query
 */
export declare function getPackageVersionId(versionId: string, connection: Connection): Promise<string>;
export declare function escapeInstallationKey(key?: string): Nullable<string>;
/**
 * Given 0Ho the package type type (Managed, Unlocked, Locked(deprecated?))
 *
 * @param packageId the 0Ho
 * @param connection For tooling query
 * @throws Error with message when package2 cannot be found
 */
export declare function getPackageType(packageId: string, connection: Connection): Promise<PackageType>;
/**
 * Given 04t the package type type (Managed, Unlocked, Locked(deprecated?))
 *
 * @param packageVersionId the 04t
 * @param connection For tooling query
 * @param installKey For tooling query, if an installation key is applicable to the package version it must be passed in the queries
 * @throws Error with message when package2 cannot be found
 */
export declare function getPackageTypeBy04t(packageVersionId: string, connection: Connection, installKey?: string): Promise<string>;
/**
 * Given a package version ID (05i) or subscriber package version ID (04t), return the subscriber package version ID (04t)
 *
 * @param versionId The suscriber package version ID
 * @param connection For tooling query
 */
export declare function getSubscriberPackageVersionId(versionId: string, connection: Connection): Promise<string>;
/**
 * Get the ContainerOptions for the specified Package2 (0Ho) IDs.
 *
 * @return Map of 0Ho id to container option api value
 * @param packageIds The list of package IDs
 * @param connection For tooling query
 */
export declare function getContainerOptions(packageIds: string[], connection: Connection): Promise<Map<string, PackageType>>;
/**
 * Return the Package2Version.HasMetadataRemoved field value for the given Id (05i)
 *
 * @param packageVersionId package version ID (05i)
 * @param connection For tooling query
 */
export declare function getHasMetadataRemoved(packageVersionId: string, connection: Connection): Promise<boolean>;
/**
 * Given a list of subscriber package version IDs (04t), return the associated version strings (e.g., Major.Minor.Patch.Build)
 *
 * @return Map of subscriberPackageVersionId to versionString
 * @param subscriberPackageVersionIds
 * @param connection For tooling query
 */
export declare function getPackageVersionStrings(subscriberPackageVersionIds: string[], connection: Connection): Promise<Map<string, string>>;
/**
 * For queries with an IN condition, determine if the WHERE clause will exceed
 * SOQL's 4000 character limit.  Perform multiple queries as needed to stay below the limit.
 *
 * @return concatenated array of records returned from the resulting query(ies)
 * @param query The full query to execute containing the replaceToken param in its IN clause
 * @param items The IN clause items.  A length-appropriate single-quoted comma-separated string chunk will be made from the items.
 * @param replaceToken A placeholder in the query's IN condition that will be replaced with the chunked items
 * @param connection For tooling query
 */
export declare function queryWithInConditionChunking<T = Record<string, unknown>>(query: string, items: string[], replaceToken: string, connection: Connection): Promise<T[]>;
/**
 * Returns the number of items that can be included in a quoted comma-separated string (e.g., "'item1','item2'") not exceeding maxLength
 */
export declare function getInClauseItemsCount(items: string[], startIndex: number, maxLength: number): number;
export declare function validateAncestorId(ancestorId: string, highestReleasedVersion: PackagingSObjects.Package2Version, explicitUseNoAncestor: boolean, isPatch: boolean, skipAncestorCheck: boolean, origSpecifiedAncestor: string): string;
export declare function getAncestorId(packageDescriptorJson: PackageDescriptorJson, project: SfProject, connection: Connection, versionNumberString: string, skipAncestorCheck: boolean): Promise<string>;
export declare function getAncestorIdHighestRelease(connection: Connection, packageId: string, versionNumberString: string, explicitUseHighestRelease: boolean, skipAncestorCheck: boolean): Promise<{
    finalAncestorId: string;
    highestReleasedVersion: PackagingSObjects.Package2Version;
}>;
/**
 * Return a version string in Major.Minor.Patch.Build format, using 0 for any empty part
 */
export declare function concatVersion(major: string | number, minor: string | number, patch: string | number, build: string | number): string;
export declare function getPackageVersionNumber(package2VersionObj: PackagingSObjects.Package2Version): string;
export declare function getConfigPackageDirectories(project: SfProject): PackageDir[];
export declare function getConfigPackageDirectory(packageDirs: NamedPackageDir[] | PackageDir[], lookupProperty: string, lookupValue: unknown): NamedPackageDir | PackageDir | undefined;
/**
 * Given a packageAlias, attempt to return the associated id from the config
 *
 * @param packageAlias string representing a package alias
 * @param project for obtaining the project config
 * @returns the associated id or the arg given.
 */
export declare function getPackageIdFromAlias(packageAlias: string, project: SfProject): string;
/**
 * @param stringIn pascal or camel case string
 * @returns space delimited and lower-cased (except for 1st char) string (e.g. in "AbcdEfghIj" => "Abcd efgh ij")
 */
export declare function convertCamelCaseStringToSentence(stringIn: string): string;
/**
 * Given a package id, attempt to return the associated aliases from the config
 *
 * @param packageId string representing a package id
 * @param project for obtaining the project config
 * @returns an array of alias for the given id.
 */
export declare function getPackageAliasesFromId(packageId: string, project: SfProject): string[];
export declare function findOrCreatePackage(seedPackage: string, connection: Connection): Promise<string>;
export declare function pollForStatusWithInterval(id: string, retries: number, packageId: string, branch: string, withProject: SfProject, connection: Connection, interval: Duration): Promise<PackageVersionCreateRequestResult>;
/**
 * Generate package alias json entry for this package version that can be written to sfdx-project.json
 *
 * @param connection
 * @param project SfProject instance for the project
 * @param packageVersionId 04t id of the package to create the alias entry for
 * @param packageVersionNumber that will be appended to the package name to form the alias
 * @param branch
 * @param packageId the 0Ho id
 * @private
 */
export declare function generatePackageAliasEntry(connection: Connection, project: SfProject, packageVersionId: string, packageVersionNumber: string, branch: string, packageId: string): Promise<{
    [p: string]: string;
}>;
export declare function formatDate(date: Date): string;
export declare function combineSaveErrors(sObject: string, crudOperation: string, errors: SaveError[]): SfError;
