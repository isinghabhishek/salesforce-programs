"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPackage = exports._generatePackageAliasEntry = exports._generatePackageDirEntry = exports._createPackageRequestFromContext = void 0;
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const pkgUtils = require("../utils/packageUtils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'messages');
function _createPackageRequestFromContext(project, options) {
    const namespace = options.noNamespace ? '' : project.getSfProjectJson().getContents().namespace || '';
    return {
        Name: options.name,
        Description: options.description,
        NamespacePrefix: namespace,
        ContainerOptions: options.packageType,
        IsOrgDependent: options.orgDependent,
        PackageErrorUsername: options.errorNotificationUsername,
    };
}
exports._createPackageRequestFromContext = _createPackageRequestFromContext;
/**
 * Generate packageDirectory json entry for this package that can be written to sfdx-project.json
 *
 * @param project
 * @param packageId the 0Ho id of the package to create the entry for
 * @private
 */
function _generatePackageDirEntry(project, options) {
    let packageDirs = project.getPackageDirectories();
    if (!packageDirs) {
        packageDirs = [];
    }
    // add an entry if it doesn't exist
    // or update an existing entry if it matches path but has no package or id attribute (W-5092620)
    let packageDir = project.getPackage(options.name) ||
        project
            .getPackageDirectories()
            // TODO: I don't understand where id is coming from, because it is not in sfdx-project.json schema
            .find((pd) => pd.path === options.path && !pd.id && !pd.package);
    if (packageDir) {
        // update existing entry
        packageDir.package = options.name;
        packageDir.versionName ?? (packageDir.versionName = pkgUtils.DEFAULT_PACKAGE_DIR.versionName);
        packageDir.versionNumber ?? (packageDir.versionNumber = pkgUtils.DEFAULT_PACKAGE_DIR.versionNumber);
        // set as default if this is the only entry or no other entry is the default
        if (!Reflect.getOwnPropertyDescriptor(packageDir, 'default')) {
            packageDir.default = !pkgUtils.getConfigPackageDirectory(packageDirs, 'default', true);
        }
    }
    else {
        // add new entry
        packageDir = pkgUtils.DEFAULT_PACKAGE_DIR;
        packageDir.package = options.name;
        // set as default if this is the only entry or no other entry is the default
        packageDir.default = !pkgUtils.getConfigPackageDirectory(packageDirs, 'default', true);
        packageDir.path = options.path;
        packageDirs.push(packageDir);
    }
    return packageDirs;
}
exports._generatePackageDirEntry = _generatePackageDirEntry;
/**
 * Generate package alias json entry for this package that can be written to sfdx-project.json
 *
 * @param context
 * @param packageId the 0Ho id of the package to create the alias entry for
 * @private
 */
function _generatePackageAliasEntry(project, options, packageId) {
    const packageAliases = project.getSfProjectJson().getContents().packageAliases || {};
    const packageName = options.name;
    packageAliases[packageName] = packageId;
    return packageAliases;
}
exports._generatePackageAliasEntry = _generatePackageAliasEntry;
async function createPackage(connection, project, options) {
    // strip trailing slash from path param
    options.path = options.path.replace(/\/$/, '');
    const request = _createPackageRequestFromContext(project, options);
    let packageId = null;
    const createResult = await connection.tooling
        .sobject('Package2')
        .create(request)
        .catch((err) => {
        const error = (0, ts_types_1.isString)(err) ? err : err.message;
        throw core_1.SfError.wrap(error);
    });
    if (!createResult.success) {
        throw pkgUtils.combineSaveErrors('Package2', 'create', createResult.errors);
    }
    packageId = createResult.id;
    const queryResult = await connection.tooling.query(`SELECT Id FROM Package2 WHERE Id='${packageId}'`);
    if (!queryResult?.records[0]) {
        throw messages.createError('unableToFindPackageWithId', [packageId]);
    }
    const record = queryResult.records[0];
    if (!process.env.SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_CREATE) {
        const packageDirectory = _generatePackageDirEntry(project, options);
        const packageAliases = _generatePackageAliasEntry(project, options, record.Id);
        const projectJson = project.getSfProjectJson();
        projectJson.set('packageDirectories', packageDirectory);
        projectJson.set('packageAliases', packageAliases);
        await projectJson.write();
    }
    return { Id: record.Id };
}
exports.createPackage = createPackage;
//# sourceMappingURL=packageCreate.js.map