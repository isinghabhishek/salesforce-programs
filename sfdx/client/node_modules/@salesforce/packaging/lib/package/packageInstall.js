"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForPublish = exports.getStatus = exports.getExternalSites = exports.installPackage = void 0;
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const packageUtils_1 = require("../utils/packageUtils");
const constants_1 = require("../constants");
core_1.Messages.importMessagesDirectory(__dirname);
const installMsgs = core_1.Messages.loadMessages('@salesforce/packaging', 'package-install');
let logger;
const getLogger = () => {
    if (!logger) {
        logger = core_1.Logger.childFromRoot('installPackage');
    }
    return logger;
};
async function installPackage(connection, pkgInstallCreateRequest, options) {
    const defaults = {
        ApexCompileType: 'all',
        EnableRss: false,
        NameConflictResolution: 'Block',
        PackageInstallSource: 'U',
        SecurityType: 'None',
        UpgradeType: 'mixed-mode',
    };
    const request = Object.assign({}, defaults, pkgInstallCreateRequest);
    if (request.Password) {
        request.Password = (0, packageUtils_1.escapeInstallationKey)(request.Password);
    }
    const pkgType = await (0, packageUtils_1.getPackageTypeBy04t)(request.SubscriberPackageVersionKey, connection, request.Password);
    // Only unlocked packages can change the UpgradeType and ApexCompile options from the defaults.
    if (pkgType !== 'Unlocked') {
        if (request.UpgradeType !== defaults.UpgradeType) {
            const msg = installMsgs.getMessage('upgradeTypeOnlyForUnlockedWarning');
            await core_1.Lifecycle.getInstance().emit('PackageInstallRequest:warning', msg);
            delete request.UpgradeType;
        }
        if (request.ApexCompileType !== defaults.ApexCompileType) {
            const msg = installMsgs.getMessage('apexCompileOnlyForUnlockedWarning');
            await core_1.Lifecycle.getInstance().emit('PackageInstallRequest:warning', msg);
            delete request.ApexCompileType;
        }
    }
    await core_1.Lifecycle.getInstance().emit('PackageInstallRequest:presend', request);
    const result = await connection.tooling.create('PackageInstallRequest', request);
    await core_1.Lifecycle.getInstance().emit('PackageInstallRequest:postsend', result);
    const packageInstallRequestId = result.id;
    if (!packageInstallRequestId) {
        throw installMsgs.createError('packageInstallRequestError', [
            request.SubscriberPackageVersionKey,
            result.errors.toString(),
        ]);
    }
    if (options?.pollingTimeout == null) {
        return getStatus(connection, packageInstallRequestId);
    }
    else {
        return pollStatus(connection, packageInstallRequestId, options);
    }
}
exports.installPackage = installPackage;
/**
 * Returns an array of RSS and CSP external sites for the package.
 *
 * @param connection The `Connection` object to the org.
 * @param subscriberPackageVersionId The ID of the subscriber package version (begins with "04t")
 * @param installationKey The installation key (if any) for the subscriber package version.
 * @returns an array of RSS and CSP site URLs, or undefined if the package doesn't have any.
 */
async function getExternalSites(connection, subscriberPackageVersionId, installationKey) {
    const queryNoKey = `SELECT RemoteSiteSettings, CspTrustedSites FROM SubscriberPackageVersion WHERE Id ='${subscriberPackageVersionId}'`;
    let queryResult;
    try {
        const escapedInstallationKey = installationKey ? (0, packageUtils_1.escapeInstallationKey)(installationKey) : null;
        const queryWithKey = `${queryNoKey} AND InstallationKey ='${escapedInstallationKey}'`;
        getLogger().debug(`Checking package: [${subscriberPackageVersionId}] for external sites`);
        queryResult = await connection.tooling.query(queryWithKey);
    }
    catch (e) {
        // First check for Implementation Restriction error that is enforced in 214, before it was possible to query
        // against InstallationKey, otherwise surface the error.
        if (e instanceof Error && (0, packageUtils_1.isErrorFromSPVQueryRestriction)(e)) {
            queryResult = await connection.tooling.query(queryNoKey);
        }
        else {
            throw e;
        }
    }
    if (queryResult?.records?.length > 0) {
        const record = queryResult.records[0];
        const rssUrls = record.RemoteSiteSettings.settings.map((rss) => rss.url);
        const cspUrls = record.CspTrustedSites.settings.map((csp) => csp.endpointUrl);
        const sites = [...rssUrls, ...cspUrls];
        if (sites.length) {
            return sites;
        }
    }
}
exports.getExternalSites = getExternalSites;
async function getStatus(connection, installRequestId) {
    const result = await connection.tooling.retrieve('PackageInstallRequest', installRequestId);
    return result;
}
exports.getStatus = getStatus;
// internal
async function pollStatus(connection, installRequestId, options) {
    let packageInstallRequest;
    const { pollingFrequency, pollingTimeout } = options;
    let frequency;
    if (pollingFrequency != null) {
        frequency = (0, ts_types_1.isNumber)(pollingFrequency) ? kit_1.Duration.milliseconds(pollingFrequency) : pollingFrequency;
    }
    else {
        frequency = kit_1.Duration.milliseconds(constants_1.consts.PACKAGE_INSTALL_POLL_FREQUENCY);
    }
    let timeout;
    if (pollingTimeout != null) {
        timeout = (0, ts_types_1.isNumber)(pollingTimeout) ? kit_1.Duration.minutes(pollingTimeout) : pollingTimeout;
    }
    else {
        timeout = kit_1.Duration.minutes(constants_1.consts.PACKAGE_INSTALL_POLL_TIMEOUT);
    }
    const pollingOptions = {
        frequency,
        timeout,
        poll: async () => {
            packageInstallRequest = await getStatus(connection, installRequestId);
            getLogger().debug(installMsgs.getMessage('packageInstallPolling', [packageInstallRequest?.Status]));
            await core_1.Lifecycle.getInstance().emit('PackageInstallRequest:status', packageInstallRequest);
            if (['SUCCESS', 'ERROR'].includes(packageInstallRequest?.Status)) {
                return { completed: true, payload: packageInstallRequest };
            }
            return { completed: false };
        },
    };
    const pollingClient = await core_1.PollingClient.create(pollingOptions);
    try {
        getLogger().debug(`Polling for PackageInstallRequest status. Package ID = ${installRequestId}`);
        getLogger().debug(`Polling frequency (ms): ${pollingOptions.frequency.milliseconds}`);
        getLogger().debug(`Polling timeout (min): ${pollingOptions.timeout.minutes}`);
        await pollingClient.subscribe();
        return packageInstallRequest;
    }
    catch (e) {
        const errMsg = e instanceof Error ? e.message : (0, ts_types_1.isString)(e) ? e : 'polling timed out';
        const error = new core_1.SfError(errMsg, 'PackageInstallTimeout');
        error.setData(packageInstallRequest);
        if (error.stack && e.stack) {
            // add the original stack to this new error
            error.stack += `\nDUE TO:\n${e.stack}`;
        }
        throw error;
    }
}
async function waitForPublish(connection, subscriberPackageVersionId, timeout, installationKey) {
    let queryResult;
    const pollingOptions = {
        frequency: kit_1.Duration.milliseconds(constants_1.consts.PACKAGE_INSTALL_POLL_FREQUENCY),
        timeout: (0, ts_types_1.isNumber)(timeout) ? kit_1.Duration.minutes(timeout) : timeout,
        poll: async () => {
            const QUERY_NO_KEY = `SELECT Id, SubscriberPackageId, InstallValidationStatus FROM SubscriberPackageVersion WHERE Id ='${subscriberPackageVersionId}'`;
            try {
                const escapedInstallationKey = installationKey ? (0, packageUtils_1.escapeInstallationKey)(installationKey) : null;
                const queryWithKey = `${QUERY_NO_KEY} AND InstallationKey ='${escapedInstallationKey}'`;
                queryResult = await connection.tooling.query(queryWithKey);
            }
            catch (e) {
                // Check first for Implementation Restriction error that is enforced in 214, before it was possible to query
                // against InstallationKey, otherwise surface the error.
                if (e instanceof Error && (0, packageUtils_1.isErrorFromSPVQueryRestriction)(e)) {
                    queryResult = await connection.tooling.query(QUERY_NO_KEY);
                }
                else {
                    if (e instanceof Error && !(0, packageUtils_1.isErrorPackageNotAvailable)(e)) {
                        throw e;
                    }
                }
            }
            // Continue retrying if there is no record
            // or for an InstallValidationStatus of PACKAGE_UNAVAILABLE (replication to the subscriber's instance has not completed)
            // or for an InstallValidationStatus of UNINSTALL_IN_PROGRESS
            let installValidationStatus;
            if (queryResult?.records?.length) {
                installValidationStatus = queryResult.records[0].InstallValidationStatus;
                await core_1.Lifecycle.getInstance().emit('SubscriberPackageVersion:status', installValidationStatus);
                if (!['PACKAGE_UNAVAILABLE', 'UNINSTALL_IN_PROGRESS'].includes(installValidationStatus)) {
                    return { completed: true, payload: queryResult };
                }
            }
            const tokens = installValidationStatus ? [` Status = ${installValidationStatus}`] : [];
            getLogger().debug(installMsgs.getMessage('publishWaitProgress', tokens));
            await core_1.Lifecycle.getInstance().emit('SubscriberPackageVersion:status', installValidationStatus);
            return { completed: false, payload: queryResult };
        },
    };
    const pollingClient = await core_1.PollingClient.create(pollingOptions);
    try {
        getLogger().debug(`Polling for package availability in org. Package ID = ${subscriberPackageVersionId}`);
        getLogger().debug(`Polling frequency (ms): ${pollingOptions.frequency.milliseconds}`);
        getLogger().debug(`Polling timeout (min): ${pollingOptions.timeout.minutes}`);
        await pollingClient.subscribe();
    }
    catch (e) {
        // if polling timed out
        const error = installMsgs.createError('subscriberPackageVersionNotPublished');
        error.setData(queryResult);
        if (error.stack && e.stack) {
            // append the original stack to this new error
            error.stack += `\nDUE TO:\n${e.stack}`;
        }
        throw error;
    }
}
exports.waitForPublish = waitForPublish;
//# sourceMappingURL=packageInstall.js.map