"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPackage = void 0;
const path = require("path");
const util = require("util");
const os = require("os");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const uniqid_1 = require("../utils/uniqid");
const pkgUtils = require("../utils/packageUtils");
const constants_1 = require("../constants");
const srcDevUtil = require("../utils/srcDevUtils");
const packageVersionCreateRequest_1 = require("./packageVersionCreateRequest");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'messages');
async function convertPackage(pkg, org, connection, project, options) {
    let maxRetries = 0;
    const branch = 'main';
    if (options.wait) {
        maxRetries = (60 / pkgUtils.POLL_INTERVAL_SECONDS) * options.wait.seconds;
    }
    const packageId = await pkgUtils.findOrCreatePackage(pkg, connection);
    const request = await createPackageVersionCreateRequest(context, packageId);
    const createResult = await connection.tooling.create('Package2VersionCreateRequest', request);
    if (!createResult.success) {
        const errStr = createResult.errors && createResult.errors.length ? createResult.errors.join(', ') : createResult.errors;
        throw messages.createError('failedToCreatePVCRequest', [
            createResult.id ? ` [${createResult.id}]` : '',
            errStr.toString(),
        ]);
    }
    let results;
    if (options.wait) {
        results = await pkgUtils.pollForStatusWithInterval(createResult.id, maxRetries, packageId, branch, project, connection, new kit_1.Duration(pkgUtils.POLL_INTERVAL_SECONDS, kit_1.Duration.Unit.SECONDS));
    }
    else {
        results = await (0, packageVersionCreateRequest_1.byId)(packageId, connection);
    }
    return util.isArray(results) ? results[0] : results;
}
exports.convertPackage = convertPackage;
/**
 * Convert the list of command line options to a JSON object that can be used to create an Package2VersionCreateRequest entity.
 *
 * @param context: command context
 * @param packageId: package2 id to create a package version for
 * @returns {{Package2Id: string, Package2VersionMetadata: *, Tag: *, Branch: number}}
 * @private
 */
async function createPackageVersionCreateRequest(context, packageId) {
    const uniqueId = (0, uniqid_1.uniqid)({ template: `${packageId}-%s` });
    const packageVersTmpRoot = path.join(os.tmpdir(), uniqueId);
    const packageVersBlobDirectory = path.join(packageVersTmpRoot, 'package-version-info');
    const packageVersBlobZipFile = path.join(packageVersTmpRoot, constants_1.consts.PACKAGE_VERSION_INFO_FILE_ZIP);
    const packageDescriptorJson = {
        id: packageId,
    };
    await fs.promises.mkdir(packageVersTmpRoot, { recursive: true });
    await fs.promises.mkdir(packageVersBlobDirectory, { recursive: true });
    await fs.promises.writeFile(path.join(packageVersBlobDirectory, constants_1.consts.PACKAGE2_DESCRIPTOR_FILE), JSON.stringify(packageDescriptorJson, undefined, 2));
    // Zip the Version Info and package.zip files into another zip
    await srcDevUtil.zipDir(packageVersBlobDirectory, packageVersBlobZipFile);
    return createRequestObject(packageId, context, packageVersTmpRoot, packageVersBlobZipFile);
}
async function createRequestObject(packageId, options, packageVersTmpRoot, packageVersBlobZipFile) {
    const zipFileBase64 = (await fs.promises.readFile(packageVersBlobZipFile)).toString('base64');
    const requestObject = {
        Package2Id: packageId,
        VersionInfo: zipFileBase64,
        InstallKey: options.installationkey,
        Instance: options.buildinstance,
        IsConversionRequest: true,
    };
    await fs.promises.unlink(packageVersTmpRoot);
    return requestObject;
}
//# sourceMappingURL=packageConvert.js.map