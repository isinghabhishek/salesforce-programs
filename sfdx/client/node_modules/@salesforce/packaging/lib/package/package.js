"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const packageList_1 = require("./packageList");
const packageInstall_1 = require("./packageInstall");
const packagePrefixes = {
    PackageId: '0Ho',
    SubscriberPackageVersionId: '04t',
    PackageInstallRequestId: '0Hf',
    PackageUninstallRequestId: '06y',
};
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package');
/**
 * Package class.
 *
 * This class provides the base implementation for a package.
 */
class Package extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * Given a Salesforce ID for a package resource and the type of resource,
     * ensures the ID is valid.
     *
     * Valid ID types and prefixes for packaging resources:
     * 1. package ID (0Ho)
     * 2. subscriber package version ID (04t)
     * 3. package install request ID (0Hf)
     * 4. package uninstall request ID (06y)
     *
     * @param id Salesforce ID for a specific package resource
     * @param type The type of package ID
     */
    static validateId(id, type) {
        const prefix = packagePrefixes[type];
        if (!id.startsWith(prefix)) {
            throw messages.createError('invalidPackageId', [type, id, prefix]);
        }
        if (!core_1.sfdc.validateSalesforceId(id)) {
            throw messages.createError('invalidIdLength', [type, id]);
        }
    }
    convert() {
        return Promise.resolve(undefined);
    }
    create() {
        return Promise.resolve(undefined);
    }
    delete() {
        return Promise.resolve(undefined);
    }
    async install(pkgInstallCreateRequest, options) {
        return (0, packageInstall_1.installPackage)(this.options.connection, pkgInstallCreateRequest, options);
    }
    async getInstallStatus(installRequestId) {
        return (0, packageInstall_1.getStatus)(this.options.connection, installRequestId);
    }
    list() {
        return (0, packageList_1.listPackages)(this.options.connection);
    }
    uninstall() {
        return Promise.resolve(undefined);
    }
    update() {
        return Promise.resolve(undefined);
    }
    async getPackage(packageId) {
        const package2 = await this.options.connection.tooling.sobject('Package2').retrieve(packageId);
        return package2;
    }
    async getExternalSites(subscriberPackageVersionId, installationKey) {
        return (0, packageInstall_1.getExternalSites)(this.options.connection, subscriberPackageVersionId, installationKey);
    }
    async waitForPublish(subscriberPackageVersionId, timeout, installationKey) {
        return (0, packageInstall_1.waitForPublish)(this.options.connection, subscriberPackageVersionId, timeout, installationKey);
    }
    init() {
        return Promise.resolve(undefined);
    }
}
exports.Package = Package;
//# sourceMappingURL=package.js.map