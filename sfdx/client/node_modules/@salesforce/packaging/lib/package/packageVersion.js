"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageVersion = void 0;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const utils_1 = require("../utils");
const packageVersionCreate_1 = require("./packageVersionCreate");
const packageVersionReport_1 = require("./packageVersionReport");
const packageVersionCreateRequestReport_1 = require("./packageVersionCreateRequestReport");
const packageVersionList_1 = require("./packageVersionList");
core_1.Messages.importMessagesDirectory(__dirname);
class PackageVersion {
    constructor(options) {
        this.options = options;
        this.connection = this.options.connection;
        this.project = this.options.project;
    }
    /**
     * Creates a new package version.
     *
     * @param options
     * @param polling frequency and timeout Durations to be used in polling
     */
    async create(options, polling = {
        frequency: kit_1.Duration.seconds(0),
        timeout: kit_1.Duration.seconds(0),
    }) {
        const pvc = new packageVersionCreate_1.PackageVersionCreate({ ...options, ...this.options });
        const createResult = await pvc.createPackageVersion();
        return await this.waitForCreateVersion(createResult.Id, polling).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, utils_1.applyErrorAction)(err);
        });
    }
    /**
     * Deletes a package version.
     *
     * @param idOrAlias
     */
    async delete(idOrAlias) {
        return this.updateDeprecation(idOrAlias, true);
    }
    /**
     * Undeletes a package version.
     *
     * @param idOrAlias
     */
    async undelete(idOrAlias) {
        return this.updateDeprecation(idOrAlias, false);
    }
    /**
     * Gets the package version report.
     *
     * @param createPackageRequestId
     * @param verbose
     */
    async report(createPackageRequestId, verbose = false) {
        const results = await (0, packageVersionReport_1.getPackageVersionReport)({
            idOrAlias: createPackageRequestId,
            connection: this.connection,
            project: this.project,
            verbose,
        }).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, utils_1.applyErrorAction)(err);
        });
        return results[0];
    }
    /**
     * Gets current state of a package version create request.
     *
     * @param createPackageRequestId
     */
    async getCreateVersionReport(createPackageRequestId) {
        return await (0, packageVersionCreateRequestReport_1.getCreatePackageVersionCreateRequestReport)({
            createPackageVersionRequestId: createPackageRequestId,
            connection: this.connection,
        }).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, utils_1.applyErrorAction)(err);
        });
    }
    /**
     * Convenience function that will wait for a package version to be created.
     *
     * This function emits LifeCycle events, "enqueued", "in-progress", "success", "error" and "timed-out" to
     * progress and current status. Events also carry a payload of type PackageVersionCreateRequestResult.
     *
     * @param packageId - The package id to wait for
     * @param createPackageVersionRequestId
     * @param polling frequency and timeout Durations to be used in polling
     * */
    async waitForCreateVersion(createPackageVersionRequestId, polling) {
        if (polling.timeout?.milliseconds <= 0) {
            return await this.getCreateVersionReport(createPackageVersionRequestId);
        }
        let remainingWaitTime = polling.timeout;
        let report;
        const pollingClient = await core_1.PollingClient.create({
            poll: async () => {
                report = await this.getCreateVersionReport(createPackageVersionRequestId);
                switch (report.Status) {
                    case 'Queued':
                        await core_1.Lifecycle.getInstance().emit('enqueued', { ...report, remainingWaitTime });
                        remainingWaitTime = kit_1.Duration.seconds(remainingWaitTime.seconds - polling.frequency.seconds);
                        return {
                            completed: false,
                            payload: report,
                        };
                    case 'InProgress':
                    case 'Initializing':
                    case 'VerifyingFeaturesAndSettings':
                    case 'VerifyingDependencies':
                    case 'VerifyingMetadata':
                    case 'FinalizingPackageVersion':
                        await core_1.Lifecycle.getInstance().emit('in-progress', { ...report, remainingWaitTime });
                        remainingWaitTime = kit_1.Duration.seconds(remainingWaitTime.seconds - polling.frequency.seconds);
                        return {
                            completed: false,
                            payload: report,
                        };
                    case 'Success':
                        await core_1.Lifecycle.getInstance().emit('success', report);
                        await this.updateProjectWithPackageVersion(this.project, report);
                        return { completed: true, payload: report };
                    case 'Error':
                        await core_1.Lifecycle.getInstance().emit('error', report);
                        return { completed: true, payload: report };
                }
            },
            frequency: polling.frequency,
            timeout: polling.timeout,
        });
        try {
            return pollingClient.subscribe();
        }
        catch (err) {
            await core_1.Lifecycle.getInstance().emit('timed-out', report);
            throw (0, utils_1.applyErrorAction)(err);
        }
    }
    convert() {
        return Promise.resolve(undefined);
    }
    install() {
        return Promise.resolve(undefined);
    }
    async list(options) {
        return (await (0, packageVersionList_1.listPackageVersions)({ ...options, ...{ connection: this.connection } })).records;
    }
    uninstall() {
        return Promise.resolve(undefined);
    }
    async promote(id) {
        // lookup the 05i ID, if needed
        if (id.startsWith('04t')) {
            id = await (0, utils_1.getPackageVersionId)(id, this.connection);
        }
        return await this.options.connection.tooling.update('Package2Version', { IsReleased: true, Id: id });
    }
    update() {
        return Promise.resolve(undefined);
    }
    async updateDeprecation(idOrAlias, IsDeprecated) {
        const packageVersionId = (0, utils_1.getPackageIdFromAlias)(idOrAlias, this.project);
        // ID can be an 04t or 05i
        (0, utils_1.validateId)([utils_1.BY_LABEL.SUBSCRIBER_PACKAGE_VERSION_ID, utils_1.BY_LABEL.PACKAGE_VERSION_ID], packageVersionId);
        // lookup the 05i ID, if needed
        const packageId = await (0, utils_1.getPackageVersionId)(packageVersionId, this.connection);
        // setup the request
        const request = {
            Id: packageId,
            IsDeprecated,
        };
        const updateResult = await this.connection.tooling.update('Package2Version', request);
        if (!updateResult.success) {
            throw (0, utils_1.combineSaveErrors)('Package2', 'update', updateResult.errors);
        }
        updateResult.id = await (0, utils_1.getSubscriberPackageVersionId)(packageVersionId, this.connection);
        return updateResult;
    }
    async updateProjectWithPackageVersion(withProject, results) {
        if (withProject && !process.env.SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_VERSION_CREATE) {
            // get the newly created package version from the server
            const versionResult = (await this.connection.tooling.query(`SELECT Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber FROM Package2Version WHERE SubscriberPackageVersionId='${results.SubscriberPackageVersionId}'`)).records[0];
            const version = `${(0, utils_1.getPackageAliasesFromId)(results.Package2Id, this.project).join()}@${versionResult.MajorVersion ?? 0}.${versionResult.MinorVersion ?? 0}.${versionResult.PatchVersion ?? 0}`;
            const build = versionResult.BuildNumber ? `-${versionResult.BuildNumber}` : '';
            const branch = versionResult.Branch ? `-${versionResult.Branch}` : '';
            // set packageAliases entry '<package>@<major>.<minor>.<patch>-<build>-<branch>: <result.subscriberPackageVersionId>'
            this.project.getSfProjectJson().getContents().packageAliases[`${version}${build}${branch}`] =
                results.SubscriberPackageVersionId;
            await this.project.getSfProjectJson().write();
        }
    }
}
exports.PackageVersion = PackageVersion;
//# sourceMappingURL=packageVersion.js.map