"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const convert_1 = require("../../../shared/convert");
const prompts_1 = require("../../../shared/prompts/prompts");
const relationshipField_1 = require("../../../shared/prompts/relationshipField");
const flags_1 = require("../../../shared/flags");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-sobject', 'generate.field', [
    'examples',
    'summary',
    'description',
    'flags.label.summary',
    'flags.object.summary',
    'flags.object.description',
    'prompts.type',
    'prompts.startingNumber',
    'prompts.defaultValue',
    'prompts.scale',
    'prompts.precision',
    'prompts.inlineHelpText',
    'prompts.required',
    'prompts.externalId',
    'prompts.securityClassification',
    'error.bigObjects',
    'error.cmdt',
    'success',
]);
const MAX_LONG_TEXT_LENGTH = 131072;
const MAX_TEXT_LENGTH = 255;
const supportedFieldTypesCustomObject = [
    'AutoNumber',
    'Checkbox',
    'Currency',
    'DateTime',
    'Date',
    'Email',
    'Html',
    'Location',
    'LongTextArea',
    'Lookup',
    'MasterDetail',
    'Number',
    'Phone',
    'Picklist',
    'Text',
    'Time',
    'Url',
];
const supportedFieldTypesPlatformEvent = ['Text', 'Number', 'DateTime', 'Date', 'LongTextArea', 'Checkbox'];
class FieldGenerate extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(FieldGenerate);
        const responses = await this.prompt([
            await (0, prompts_1.objectPrompt)(this.project.getPackageDirectories()),
            (0, prompts_1.apiNamePrompt)(flags.label, 'CustomField'),
            {
                type: 'list',
                message: messages.getMessage('prompts.type'),
                name: 'type',
                choices: (answers) => getSupportedFieldTypes(answers.object),
            },
            // AutoNumber
            {
                type: 'number',
                message: messages.getMessage('prompts.startingNumber'),
                validate: (n) => (0, prompts_1.integerValidation)(n, 0, Number.MAX_SAFE_INTEGER),
                name: 'startingNumber',
                when: (answers) => answers.type === 'AutoNumber',
                default: 0,
            },
            // checkbox type requires a default value
            {
                type: 'list',
                message: messages.getMessage('prompts.defaultValue'),
                choices: [
                    { value: false, name: 'false' },
                    { value: true, name: 'true' },
                ],
                name: 'defaultValue',
                when: (answers) => answers.type === 'Checkbox',
                default: false,
            },
            // text types
            {
                type: 'number',
                message: `Length (max ${MAX_LONG_TEXT_LENGTH})`,
                validate: (n) => (0, prompts_1.integerValidation)(n, 1, MAX_LONG_TEXT_LENGTH),
                name: 'length',
                when: (answers) => ['Html', 'LongTextArea'].includes(answers.type),
                default: MAX_LONG_TEXT_LENGTH,
            },
            {
                type: 'number',
                message: `Length (max ${MAX_TEXT_LENGTH})`,
                validate: (n) => (0, prompts_1.integerValidation)(n, 1, MAX_TEXT_LENGTH),
                name: 'length',
                when: (answers) => answers.type === 'Text',
                default: MAX_TEXT_LENGTH,
            },
            {
                type: 'number',
                message: 'Visible Lines',
                validate: (n) => (0, prompts_1.integerValidation)(n, 1, 1000),
                name: 'visibleLines',
                when: (answers) => ['Html', 'LongTextArea'].includes(answers.type),
                default: 5,
            },
            // number types
            {
                type: 'number',
                message: messages.getMessage('prompts.scale'),
                validate: (n) => (0, prompts_1.integerValidation)(n, 0, 18),
                name: 'scale',
                when: (answers) => ['Number', 'Currency', 'Location'].includes(answers.type),
                default: 0,
            },
            {
                type: 'number',
                message: messages.getMessage('prompts.precision'),
                validate: (n, answers) => (0, prompts_1.integerValidation)(n, 1, 18 - answers.scale),
                name: 'precision',
                when: (answers) => ['Number', 'Currency'].includes(answers.type),
                default: (answers) => 18 - answers.scale,
            },
            // non-fieldtype-specific questions
            prompts_1.descriptionPrompt,
            {
                type: 'input',
                message: messages.getMessage('prompts.inlineHelpText'),
                name: 'inlineHelpText',
                when: (answers) => !answers.object.includes('__e'),
            },
            {
                type: 'confirm',
                message: messages.getMessage('prompts.required'),
                name: 'required',
                when: (answers) => !['Checkbox', 'MasterDetail', 'Lookup', 'LongTextArea'].includes(answers.type),
                default: false,
            },
            {
                type: 'confirm',
                message: 'Unique',
                name: 'unique',
                when: (answers) => ['Number', 'Text'].includes(answers.type),
                default: false,
            },
            {
                type: 'confirm',
                message: messages.getMessage('prompts.externalId'),
                name: 'externalId',
                when: (answers) => ['Number', 'Text'].includes(answers.type) && answers.object?.endsWith('__e'),
                default: false,
            },
            {
                type: 'list',
                message: messages.getMessage('prompts.securityClassification'),
                name: 'securityClassification',
                choices: ['Public', 'Internal', 'Confidential', 'Restricted', 'Mission Critical'],
                default: 'Internal',
            },
        ], 
        // pre-populate the object if they gave us one
        flags.object ? { object: flags.object } : {});
        const { object, ...customField } = responses;
        const result = {
            field: {
                ...customField,
                label: flags.label,
                // always use decimal version of location unless someone asks us not to in a feature request
                ...(customField.type === 'Location' ? { displayLocationInDecimal: true } : {}),
                // building picklists is an independent inquirer series of questions
                ...(customField.type === 'Picklist' ? { valueSet: await (0, prompts_1.picklistPrompts)() } : {}),
                // relationship fields have their own series of questions
                ...(responses.type === 'MasterDetail' || responses.type === 'Lookup'
                    ? await (0, relationshipField_1.relationshipFieldPrompts)({
                        type: responses.type,
                        packageDirs: this.project.getPackageDirectories(),
                        childObjectFolderPath: responses.object,
                    })
                    : {}),
            },
            path: path.join(object, 'fields', `${responses.fullName}.field-meta.xml`),
        };
        this.styledJSON(result);
        await fs.promises.mkdir(path.join(object, 'fields'), { recursive: true });
        await fs.promises.writeFile(result.path, (0, convert_1.convertJsonToXml)({ json: result.field, type: 'CustomField' }));
        this.logSuccess(messages.getMessage('success', [path.join(object, 'fields', `${responses.fullName}.field-meta.xml`)]));
        return result;
    }
}
exports.default = FieldGenerate;
_a = FieldGenerate;
FieldGenerate.summary = messages.getMessage('summary');
FieldGenerate.description = messages.getMessage('description');
FieldGenerate.examples = messages.getMessages('examples');
FieldGenerate.requiresProject = true;
FieldGenerate.enableJsonFlag = false;
FieldGenerate.state = 'beta';
FieldGenerate.flags = {
    label: sf_plugins_core_1.Flags.string({
        char: 'l',
        summary: messages.getMessage('flags.label.summary'),
        required: true,
        parse: async (label) => (0, flags_1.labelValidation)(label),
    }),
    // this a dir and not an API name to support 1 object being in multiple package directories
    object: sf_plugins_core_1.Flags.directory({
        char: 'o',
        exists: true,
        summary: messages.getMessage('flags.object.summary'),
        description: messages.getMessage('flags.object.description'),
        parse: async (input) => (0, flags_1.isObjectsFolder)(input),
    }),
};
/**
 *
 * @param objFolder examples `force-app/main/default/objects/Foo__c` or `force-app/main/default/objects/Foo__e`
 */
const getSupportedFieldTypes = (objFolder) => {
    if (objFolder.endsWith('__b')) {
        throw new Error(messages.getMessage('error.bigObjects'));
    }
    if (objFolder.endsWith('__mdt')) {
        throw new Error(messages.getMessage('error.cmdt'));
    }
    if (objFolder.includes('__e')) {
        return supportedFieldTypesPlatformEvent;
    }
    return supportedFieldTypesCustomObject;
};
//# sourceMappingURL=field.js.map