"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.picklistPrompts = exports.integerValidation = exports.objectPrompt = exports.namePrompts = exports.descriptionPrompt = exports.apiNamePrompt = exports.pluralPrompt = exports.directoryPrompt = exports.makeNameApiCompatible = void 0;
const inquirer_1 = require("inquirer");
const core_1 = require("@salesforce/core");
const fs_1 = require("../fs");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-sobject', 'prompts.shared', [
    'directory',
    'pluralLabel',
    'apiName',
    'description',
    'nameFieldPrompts.autoNumberFormat',
    'nameFieldPrompts.label',
    'nameFieldPrompts.type',
    'object',
    'picklist.first',
    'picklist.additional',
    'numberValidationMin',
    'numberValidationMax',
    'error.noDescription',
]);
const makeNameApiCompatible = (input) => input.replace(/ /g, '').replace(/-/g, '_').replace(/_{2,}/g, '_');
exports.makeNameApiCompatible = makeNameApiCompatible;
const getSuffix = (objectType) => {
    switch (objectType) {
        case 'CustomObject':
        case 'CustomField':
            return '__c';
        case 'PlatformEvent':
            return '__e';
    }
};
const directoryPrompt = async (packageDirs) => ({
    type: 'list',
    message: messages.getMessage('directory'),
    name: 'directory',
    choices: await (0, fs_1.getDirectoriesThatContainObjects)(packageDirs.map((pd) => pd.path)),
});
exports.directoryPrompt = directoryPrompt;
const pluralPrompt = (label) => ({
    type: 'input',
    message: messages.getMessage('pluralLabel'),
    name: 'pluralLabel',
    default: `${label}s`,
});
exports.pluralPrompt = pluralPrompt;
const apiNamePrompt = (label, objectType) => ({
    type: 'input',
    message: messages.getMessage('apiName'),
    name: 'fullName',
    default: `${(0, exports.makeNameApiCompatible)(label)}${getSuffix(objectType)}`,
});
exports.apiNamePrompt = apiNamePrompt;
exports.descriptionPrompt = {
    type: 'input',
    message: messages.getMessage('description'),
    name: 'description',
    validate: (input) => (input.length ? true : messages.getMessage('error.noDescription')),
};
/** Ask about the name/type for the Name field, with a followup for AutoNumber format if AutoNumber is chosen  */
const namePrompts = (label) => [
    {
        type: 'input',
        message: messages.getMessage('nameFieldPrompts.label'),
        name: 'nameFieldLabel',
        default: `${label} Name`,
    },
    {
        type: 'list',
        message: messages.getMessage('nameFieldPrompts.type'),
        name: 'nameFieldType',
        default: 'Text',
        choices: ['Text', 'AutoNumber'],
    },
    {
        type: 'input',
        when: (answers) => answers.nameFieldType === 'AutoNumber',
        message: messages.getMessage('nameFieldPrompts.autoNumberFormat'),
        name: 'autoNumberFormat',
        default: `${label}-{0}`,
    },
];
exports.namePrompts = namePrompts;
/**
 *
 * @param packageDirs
 * @param name The "name" property of the Inquirer answer object.  Supports use of the question for multiple scenarios
 */
const objectPrompt = async (packageDirs, name = 'object', message = messages.getMessage('object')) => ({
    type: 'list',
    message,
    name,
    choices: (await (0, fs_1.getObjectDirectories)(packageDirs.map((pd) => pd.path)))
        .sort()
        .map((objDir) => ({ value: objDir, name: objDir.split('/').pop() })),
});
exports.objectPrompt = objectPrompt;
const integerValidation = (value, min, max) => {
    if (value < min)
        return messages.getMessage('numberValidationMin', [value, min]);
    if (value > max)
        return messages.getMessage('numberValidationMax', [value, max]);
    return true;
};
exports.integerValidation = integerValidation;
/**
 * recursively keep adding picklist values until the user says to stop
 */
const picklistPrompts = async () => {
    const output = [];
    let keepAsking = true;
    while (keepAsking) {
        // the very definition of needing a loop for an await
        // eslint-disable-next-line no-await-in-loop
        const response = await (0, inquirer_1.prompt)({
            type: 'input',
            name: 'picklistValue',
            validate: (input) => (output.find((v) => v.fullName === input) ? `${input} already exists` : true),
            message: output.length === 0 ? messages.getMessage('picklist.first') : messages.getMessage('picklist.additional'),
        });
        if (response.picklistValue === undefined || response.picklistValue === '') {
            keepAsking = false;
        }
        else {
            output.push({
                fullName: response.picklistValue,
                label: response.picklistValue,
                default: output.length === 0,
            });
        }
    }
    return {
        valueSetDefinition: {
            value: output,
            sorted: true,
        },
    };
};
exports.picklistPrompts = picklistPrompts;
//# sourceMappingURL=prompts.js.map