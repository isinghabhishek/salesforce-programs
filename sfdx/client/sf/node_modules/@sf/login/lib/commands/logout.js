"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_2 = require("@salesforce/core");
const inquirer_1 = require("inquirer");
const chalk = require("chalk");
const sf_plugins_core_2 = require("@salesforce/sf-plugins-core");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-login', 'logout');
class Logout extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Logout);
        const hookResults = await sf_plugins_core_2.SfHook.run(this.config, 'sf:logout');
        const deauthorizers = hookResults.successes.flatMap((r) => r.result);
        if (flags['no-prompt']) {
            this.log(chalk.red.bold('Running logout with no prompts. This will log you out of all your environments.'));
            const results = { successes: [], failures: [] };
            for (const deauthorizer of deauthorizers) {
                const result = await deauthorizer.removeAll();
                results.successes.push(...result.successes);
                results.failures.push(...result.failures);
            }
            this.log(messages.getMessage('success', [results.successes.join(', ')]));
            if (results.failures.length) {
                process.exitCode = 1;
                this.log(messages.getMessage('failure', [results.failures.join(', ')]));
            }
            return results;
        }
        const { selected, confirmed } = await this.promptForEnvironments(deauthorizers);
        if (!selected.length) {
            this.log(messages.getMessage('no-environments'));
            return { successes: [], failures: [] };
        }
        if (!confirmed) {
            return { successes: [], failures: [] };
        }
        else if (!selected.length) {
            this.log(messages.getMessage('no-environments'));
            return { successes: [], failures: [] };
        }
        else if (confirmed && selected.length) {
            const results = { successes: [], failures: [] };
            for (const env of selected) {
                const result = await env.deauthorizer.remove(env.id);
                if (result)
                    results.successes.push(env.id);
                else
                    results.failures.push(env.id);
            }
            this.log(messages.getMessage('success', [results.successes.join(', ')]));
            if (results.failures.length) {
                process.exitCode = 1;
                this.log(messages.getMessage('failure', [results.failures.join(', ')]));
            }
            return results;
        }
        else {
            return { successes: [], failures: [] };
        }
    }
    async promptForEnvironments(deauthorizers) {
        const hash = {};
        for (const deauthorizer of deauthorizers) {
            const envs = await deauthorizer.find();
            Object.entries(envs).forEach(([id, env]) => {
                var _a;
                const aliases = (_a = env.aliases) !== null && _a !== void 0 ? _a : [];
                const displayName = aliases.length ? `${id} (${aliases.join(', ')})` : `${id}`;
                hash[displayName] = { deauthorizer, id };
            });
        }
        const maxKeyLength = Object.keys(hash).reduce((a, b) => Math.max(a, b.length), 0);
        const { envs, confirmed } = await (0, inquirer_1.prompt)([
            {
                name: 'envs',
                message: messages.getMessage('prompt.select-envs'),
                type: 'checkbox',
                choices: [...Object.keys(hash).sort(), new inquirer_1.Separator('-'.repeat(maxKeyLength))],
                loop: true,
            },
            {
                name: 'confirmed',
                when: (answers) => answers.envs.length > 0,
                message: (answers) => {
                    this.log(messages.getMessage('warning'));
                    const names = answers.envs.map((a) => hash[a].id);
                    if (names.length === Object.keys(hash).length) {
                        return messages.getMessage('prompt.confirm-all');
                    }
                    else {
                        return messages.getMessage('prompt.confirm', [names.length, names.length > 1 ? 's' : '']);
                    }
                },
                type: 'confirm',
            },
        ]);
        return {
            selected: envs.map((a) => hash[a]),
            confirmed,
        };
    }
}
exports.default = Logout;
Logout.summary = messages.getMessage('summary');
Logout.description = messages.getMessage('description');
Logout.examples = messages.getMessages('examples');
Logout.flags = {
    'no-prompt': core_1.Flags.boolean({
        description: messages.getMessage('flags.no-prompt.summary'),
        default: false,
    }),
};
//# sourceMappingURL=logout.js.map