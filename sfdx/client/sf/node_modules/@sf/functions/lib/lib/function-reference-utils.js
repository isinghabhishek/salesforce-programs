"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveFunctionReferences = exports.ensureArray = exports.splitFullName = exports.filterProjectReferencesToRemove = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const lodash_1 = require("lodash");
const path_utils_1 = require("./path-utils");
const project_toml_1 = require("./project-toml");
function filterProjectReferencesToRemove(allReferences, successfulReferences, projectName) {
    const filtered = allReferences.filter((ref) => ref.project === projectName);
    return (0, lodash_1.differenceWith)(filtered, successfulReferences, lodash_1.isEqual).map((ref) => `${ref.project}-${ref.fn}`);
}
exports.filterProjectReferencesToRemove = filterProjectReferencesToRemove;
function splitFullName(fullName) {
    const [project, fn] = fullName.split('-');
    return {
        project,
        fn,
    };
}
exports.splitFullName = splitFullName;
function ensureArray(refList) {
    if (!refList) {
        // Since the metadata API can sometimes return `undefined` rather than an empty array if no
        // records are found, we cast it into an empty array to avoid any weird "cannot read property
        // foo of undefined" errors further down
        return [];
    }
    if (!Array.isArray(refList)) {
        refList = [refList];
    }
    return refList;
}
exports.ensureArray = ensureArray;
async function resolveFunctionReferences(project) {
    // Locate functions directory and grab paths for all function names, error if not in project or no
    // functions found
    const fnPaths = await (0, path_utils_1.resolveFunctionsPaths)();
    // Create function reference objects
    return Promise.all(fnPaths.map(async (fnPath) => {
        var _a;
        const projectTomlPath = path.join(fnPath, 'project.toml');
        const projectToml = await (0, project_toml_1.parseProjectToml)(projectTomlPath);
        const fnName = projectToml.com.salesforce.id;
        const access = projectToml.com.salesforce.access;
        const fnReference = {
            fullName: `${project.name}-${fnName}`,
            label: fnName,
            description: projectToml.com.salesforce.description,
        };
        const permissionSet = (_a = projectToml._.metadata) === null || _a === void 0 ? void 0 : _a.permissionSet;
        if (permissionSet) {
            fnReference.permissionSet = permissionSet;
        }
        if (access) {
            fnReference.access = access;
        }
        return fnReference;
    }));
}
exports.resolveFunctionReferences = resolveFunctionReferences;
