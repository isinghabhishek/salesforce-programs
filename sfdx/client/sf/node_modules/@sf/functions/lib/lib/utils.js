"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveOrg = exports.getOrgAlias = exports.getOrgUsername = exports.findOrgExpirationStatus = exports.findOrgAuthorization = exports.resolveAppNameForEnvironment = exports.fetchAppForProject = exports.fetchSfdxProject = exports.fetchOrgId = exports.fetchOrg = void 0;
const core_1 = require("@salesforce/core");
const heroku_variant_1 = require("./heroku-variant");
async function fetchOrg(aliasOrUsername) {
    // if `aliasOrUsername` is null here, Org.create will pull the default org from the surrounding environment
    return core_1.Org.create({
        aliasOrUsername,
    });
}
exports.fetchOrg = fetchOrg;
async function fetchOrgId(aliasOrUsername) {
    const org = await fetchOrg(aliasOrUsername);
    return org.getOrgId();
}
exports.fetchOrgId = fetchOrgId;
async function fetchSfdxProject() {
    const project = await core_1.SfdxProject.resolve();
    return project.resolveProjectConfig();
}
exports.fetchSfdxProject = fetchSfdxProject;
async function fetchAppForProject(client, projectName, orgAliasOrUsername) {
    const orgId = await fetchOrgId(orgAliasOrUsername);
    const { data } = await client.get(`/sales-org-connections/${orgId}/apps/${projectName}`, {
        headers: Object.assign({}, (0, heroku_variant_1.default)('evergreen')),
    });
    return data;
}
exports.fetchAppForProject = fetchAppForProject;
async function resolveAppNameForEnvironment(appNameOrAlias) {
    // Check if the environment provided is an alias or not, to determine what app name we use to attempt deletion
    const stateAggregator = await core_1.StateAggregator.getInstance();
    const matchingAlias = stateAggregator.aliases.getValue(appNameOrAlias);
    let appName;
    if (matchingAlias) {
        appName = matchingAlias;
    }
    else {
        appName = appNameOrAlias;
    }
    return appName;
}
exports.resolveAppNameForEnvironment = resolveAppNameForEnvironment;
async function findOrgAuthorization(orgId) {
    const infos = await core_1.AuthInfo.listAllAuthorizations();
    if (infos.length === 0)
        throw new Error('No connected orgs found');
    return infos.find((info) => info.orgId === orgId);
}
exports.findOrgAuthorization = findOrgAuthorization;
async function findOrgExpirationStatus(orgId) {
    const orgAuthorization = await findOrgAuthorization(orgId);
    return orgAuthorization === null || orgAuthorization === void 0 ? void 0 : orgAuthorization.isExpired;
}
exports.findOrgExpirationStatus = findOrgExpirationStatus;
async function getOrgUsername(orgId) {
    const org = await resolveOrg(orgId);
    return org === null || org === void 0 ? void 0 : org.getUsername();
}
exports.getOrgUsername = getOrgUsername;
async function getOrgAlias(orgId) {
    const stateAggregator = await core_1.StateAggregator.getInstance();
    const entries = Object.entries(stateAggregator.aliases.getAll());
    const username = await getOrgUsername(orgId);
    const matchingAlias = entries.find((entry) => entry[1] === username);
    if (matchingAlias) {
        return matchingAlias[0];
    }
}
exports.getOrgAlias = getOrgAlias;
async function resolveOrg(orgId) {
    let org;
    if (orgId) {
        const matchingOrgAuth = await findOrgAuthorization(orgId);
        if (matchingOrgAuth) {
            org = await core_1.Org.create({ aliasOrUsername: matchingOrgAuth.username });
        }
    }
    if (!org) {
        throw new Error('Attempted to resolve an org without a valid org ID');
    }
    return org;
}
exports.resolveOrg = resolveOrg;
