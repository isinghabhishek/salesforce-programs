"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const url_1 = require("url");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const cli_ux_1 = require("cli-ux");
const api_client_1 = require("./api-client");
const heroku_variant_1 = require("./heroku-variant");
class Command extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        this.outputJSON = false;
    }
    async init() {
        await super.init();
        this.stateAggregator = await core_1.StateAggregator.getInstance();
    }
    get identityUrl() {
        const defaultUrl = 'https://cli-auth.heroku.com';
        const envVarUrl = process.env.SALESFORCE_FUNCTIONS_IDENTITY_URL;
        const identityUrl = new url_1.URL(envVarUrl || defaultUrl);
        return identityUrl;
    }
    get username() {
        var _a;
        return (_a = this.stateAggregator.tokens.get(Command.TOKEN_BEARER_KEY)) === null || _a === void 0 ? void 0 : _a.user;
    }
    resetClientAuth() {
        delete this._auth;
        delete this._client;
    }
    get auth() {
        var _a;
        if (!this._auth) {
            const apiKey = process.env.SALESFORCE_FUNCTIONS_API_KEY;
            if (apiKey) {
                this._auth = apiKey;
            }
            else {
                const token = (_a = this.stateAggregator.tokens.get(Command.TOKEN_BEARER_KEY, true)) === null || _a === void 0 ? void 0 : _a.token;
                if (!token) {
                    throw new Error(`Not authenticated. Please login with \`${this.config.bin} login functions\`.`);
                }
                this._auth = token;
            }
        }
        return this._auth;
    }
    get client() {
        if (this._client) {
            return this._client;
        }
        const options = {
            auth: this.auth,
            apiUrl: (0, api_client_1.herokuClientApiUrl)(),
        };
        this._client = new api_client_1.default(options);
        return this._client;
    }
    catch(err) {
        var _a, _b;
        cli_ux_1.cli.action.stop('failed');
        if (((_b = (_a = err.http) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.status) === 401) {
            this.error('Your token has expired, please login with sf login functions');
        }
        else {
            throw err;
        }
    }
    async fetchAccount() {
        const { data } = await this.client.get('/account', {
            headers: Object.assign({}, (0, heroku_variant_1.default)('salesforce_sso')),
        });
        return data;
    }
    async isFunctionsEnabled(org) {
        const conn = org.getConnection();
        // This is a roundabout away of checking if a given org has Functions enabled. If they do NOT have functions enabled,
        // then querying for FunctionReferences will throw an error which complains about not having access to the
        // FunctionReference object for the given org.
        try {
            await conn.metadata.list({ type: 'FunctionReference' });
            return true;
        }
        catch (err) {
            const error = err;
            if (error.name.includes('INVALID_TYPE') ||
                error.message.includes('Cannot use: FunctionReference in this organization')) {
                return false;
            }
            // If we get here, something very unexpected has happened so just bail
            throw error;
        }
    }
    fetchConfirmationValue(name, confirm) {
        // If multiple confirm values have been specified, we iterate over each one until finding something that could match
        // If there isn't a match, we'll simply return undefined
        if (Array.isArray(confirm)) {
            return confirm.find((value) => value === name);
        }
        return confirm;
    }
    async confirmRemovePrompt(type, name, confirm, warningMessage) {
        const confirmedValue = this.fetchConfirmationValue(name, confirm);
        if (name !== confirmedValue) {
            warningMessage = warningMessage || `This will delete the ${type} ${name}`;
            this.warn(`${warningMessage}\nTo proceed, enter the ${type} name (${name}) again in the prompt below:`);
            // This is a workaround for cli-ux
            // & fancy-test stubbing issues
            // cli-ux mocks itself incorrectly (tbd why)
            // and causes tests to fail (false negatives)
            // Move this import up to the top of the file
            // when that issue has been resolved
            const prompt = await cli_ux_1.cli.prompt('');
            if (prompt !== name) {
                this.error('Confirmation name does not match');
            }
        }
    }
    error(input, options = {}) {
        if (this.outputJSON) {
            if (typeof input === 'string')
                input = new Error(input);
            const { message, name } = input;
            cli_ux_1.cli.styledJSON({
                status: 1,
                message,
                name,
                warnings: [],
            });
            this.exit(1);
        }
        else {
            super.error(input, options);
        }
    }
    postParseHook(flags) {
        this.outputJSON = flags.json;
    }
}
exports.default = Command;
Command.TOKEN_BEARER_KEY = 'functions-bearer';
Command.TOKEN_REFRESH_KEY = 'functions-refresh';
