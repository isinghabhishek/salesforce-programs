"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readLogs = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const Stream = require("stream");
const util = require("util");
const EventSource = require("@heroku/eventsource");
const axios_1 = require("axios");
const cli_ux_1 = require("cli-ux");
function lineTransform() {
    const transform = new Stream.Transform({ objectMode: true, decodeStrings: false });
    let _lastLineData;
    transform._transform = function (chunk, _encoding, next) {
        let data = chunk;
        if (_lastLineData)
            data = _lastLineData + data;
        const lines = data.split('\n');
        _lastLineData = lines.splice(lines.length - 1, 1)[0];
        lines.forEach(this.push.bind(this));
        next();
    };
    transform._flush = function (done) {
        if (_lastLineData)
            this.push(_lastLineData);
        _lastLineData = '';
        done();
    };
    return transform;
}
function eventSourceStream(url, eventSourceOptions, tail) {
    let eventSource;
    const stream = new Stream.Readable({
        read(_size) {
            if (!eventSource) {
                eventSource = new EventSource(url, eventSourceOptions);
                eventSource.addEventListener('error', (error) => {
                    let msg;
                    if (error.status) {
                        msg = [404, 403].includes(error.status)
                            ? 'Log stream timed out. Please try again'
                            : `Logs eventsource failed with ${error.status} ${error.message}`;
                    }
                    else if (error.message) {
                        msg = error.message;
                    }
                    if (msg) {
                        // something bad happened. we probably can't recover, so end the stream and emit an error
                        stream.destroy(new Error(msg));
                    }
                    else if (!tail) {
                        // closed by server for a different reason; out of logs, connection closed without error
                        // Since we are not tailing, send the EOF signal to close the stream
                        stream.push(null);
                    }
                });
                eventSource.addEventListener('message', (event) => {
                    stream.push(event.data);
                });
            }
        },
        destroy(error, callback) {
            if (eventSource) {
                // ensure connection to the server is closed always
                eventSource.close();
            }
            callback(error);
        },
    });
    return stream;
}
async function simpleStreamingStream(logSessionURL) {
    const response = await (0, axios_1.default)({
        method: 'get',
        url: logSessionURL,
        responseType: 'stream',
    });
    const liner = lineTransform();
    response.data.setEncoding('utf8');
    return response.data.pipe(liner);
}
function eventSourceStreamer(logSessionURL, tail) {
    return eventSourceStream(logSessionURL, {}, tail);
}
async function readLogs(logSessionURL, tail) {
    const u = new URL(logSessionURL);
    const stream = u.searchParams.has('srv')
        ? await simpleStreamingStream(logSessionURL)
        : eventSourceStreamer(logSessionURL, tail);
    stream.setEncoding('utf8');
    stream.on('data', (data) => {
        cli_ux_1.cli.log(data);
    });
    const finished = util.promisify(Stream.finished);
    await finished(stream);
}
exports.readLogs = readLogs;
