"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const heroku_variant_1 = require("../lib/heroku-variant");
const utils_1 = require("../lib/utils");
const api_client_1 = require("../lib/api-client");
async function fetchAccount(client) {
    const { data } = await client.get('/account', {
        headers: Object.assign({}, (0, heroku_variant_1.default)('salesforce_sso')),
    });
    return data;
}
async function resolveEnvironments(orgs) {
    var _a;
    const stateAggregator = await core_1.StateAggregator.getInstance();
    const apiKey = process.env.SALESFORCE_FUNCTIONS_API_KEY;
    let auth;
    if (apiKey) {
        auth = apiKey;
    }
    else {
        const token = (_a = stateAggregator.tokens.get('functions-bearer', true)) === null || _a === void 0 ? void 0 : _a.token;
        if (!token) {
            throw new Error('Not authenticated. Please login with `sf login functions`.');
        }
        auth = token;
    }
    const client = new api_client_1.default({
        auth,
        apiUrl: (0, api_client_1.herokuClientApiUrl)(),
    });
    const account = await fetchAccount(client);
    const { data: environments } = await client.get(`/enterprise-accounts/${account.salesforce_org.owner.id}/apps`, {
        headers: Object.assign({}, (0, heroku_variant_1.default)('evergreen')),
    });
    const environmentsWithAliases = await resolveAliasesForComputeEnvironments(environments);
    return resolveAliasesForConnectedOrg(environmentsWithAliases, orgs);
}
async function resolveAliasForValue(environmentName, entries) {
    // Because there's no reliable way to query aliases *by their value*, we instead grab *all* of
    // the aliases and create a reverse lookup table that is keyed on the alias values rather than
    // the aliases themselves.
    var _a;
    const aliasReverseLookup = entries.reduce((acc, [alias, environmentName]) => {
        if (typeof environmentName !== 'string') {
            return acc;
        }
        // You might have looked at this and realized that a user could potentially have multiple
        // aliases that point to the same value, in which case we could be clobbering a previous
        // entry here by simply assigning the current alias to the value in the lookup table
        // Congratulations! You are correct, but since we don't have any way to know which alias is
        // the one they care about, we simply have to pick one
        acc[environmentName] = alias;
        return acc;
    }, {});
    return (_a = aliasReverseLookup[environmentName]) !== null && _a !== void 0 ? _a : '';
}
async function resolveAliasesForComputeEnvironments(envs) {
    const stateAggregator = await core_1.StateAggregator.getInstance();
    const entries = Object.entries(stateAggregator.aliases.getAll());
    return Promise.all(envs.map(async (env) => {
        return Object.assign(Object.assign({}, env), { alias: await resolveAliasForValue(env.id, entries) });
    }));
}
function resolveAliasesForConnectedOrg(envs, orgs) {
    return envs.map((env) => {
        var _a;
        const orgId = (_a = env.sales_org_connection) === null || _a === void 0 ? void 0 : _a.sales_org_id;
        const orgAlias = orgs.reduce((result, org) => {
            var _a;
            if (org.orgId === orgId) {
                return (_a = (org.aliases && org.aliases[0])) !== null && _a !== void 0 ? _a : '';
            }
            return result;
        }, '');
        return Object.assign(Object.assign({}, env), { orgAlias });
    });
}
const hook = async function (opts) {
    const orgs = await core_1.AuthInfo.listAllAuthorizations();
    let environments = await resolveEnvironments(orgs);
    if (!opts.all) {
        // If the user IS in an SFDX project folder, we will filter compute environments down to ones associated with the project.
        // If they are not, this will throw an error which we will swallow.
        try {
            const project = await (0, utils_1.fetchSfdxProject)();
            environments = environments.filter((env) => env.sfdx_project_name === project.name);
        }
        catch (e) { }
    }
    return [
        {
            type: sf_plugins_core_1.EnvList.EnvType.computeEnvs,
            title: 'Compute Environments',
            data: environments.map((env) => {
                var _a;
                return {
                    alias: env.alias,
                    projectName: env.sfdx_project_name,
                    connectedOrgAlias: env.orgAlias,
                    connectedOrgId: (_a = env.sales_org_connection) === null || _a === void 0 ? void 0 : _a.sales_org_id,
                    computeEnvironmentName: env.name,
                    computeEnvironmentId: env.id,
                };
            }),
        },
    ];
};
exports.default = hook;
