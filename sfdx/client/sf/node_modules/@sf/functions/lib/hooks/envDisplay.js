"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const api_client_1 = require("../lib/api-client");
const function_reference_utils_1 = require("../lib/function-reference-utils");
const heroku_variant_1 = require("../lib/heroku-variant");
const utils_1 = require("../lib/utils");
const hook = async function (opts) {
    var _a, _b, _c;
    const stateAggregator = await core_1.StateAggregator.getInstance();
    const apiKey = process.env.SALESFORCE_FUNCTIONS_API_KEY;
    let auth;
    if (apiKey) {
        auth = apiKey;
    }
    else {
        const token = (_a = stateAggregator.tokens.get('functions-bearer', true)) === null || _a === void 0 ? void 0 : _a.token;
        if (!token) {
            throw new Error('Not authenticated. Please login with `sf login functions`.');
        }
        auth = token;
    }
    const client = new api_client_1.default({
        auth,
        apiUrl: (0, api_client_1.herokuClientApiUrl)(),
    });
    const { targetEnv } = opts;
    // Check if the environment provided is an alias or not, to determine what app name we use to attempt deletion
    const appName = await (0, utils_1.resolveAppNameForEnvironment)(targetEnv);
    try {
        // If app exists, environment details will be displayed
        const { data: app } = await client.get(`/apps/${appName}`, {
            headers: Object.assign({}, (0, heroku_variant_1.default)('evergreen')),
        });
        const org = await (0, utils_1.resolveOrg)((_b = app.sales_org_connection) === null || _b === void 0 ? void 0 : _b.sales_org_id);
        const orgId = org.getOrgId();
        const project = await (0, utils_1.fetchSfdxProject)();
        const isExpired = await (0, utils_1.findOrgExpirationStatus)(orgId);
        let fnNames;
        if (!isExpired) {
            const connection = org.getConnection();
            const refList = await connection.metadata.list({ type: 'FunctionReference' });
            fnNames = (0, function_reference_utils_1.ensureArray)(refList).map((ref) => ref.fullName.split('-')[1]);
        }
        const alias = appName === targetEnv ? undefined : targetEnv;
        const connectedOrgAlias = await (0, utils_1.getOrgAlias)(orgId);
        const connectedOrgUsername = await (0, utils_1.getOrgUsername)(orgId);
        const returnValue = {
            // renamed properties
            alias,
            environmentName: app.name,
            project: project.name,
            createdDate: app.created_at,
            connectedOrgId: orgId,
            connectedOrgStatus: isExpired ? 'Expired' : 'Active',
            connectedOrgAlias,
            connectedOrgUsername,
            functions: fnNames,
            appId: app.id,
            spaceId: (_c = app.space) === null || _c === void 0 ? void 0 : _c.id,
        };
        return {
            data: returnValue,
            keys: {
                appId: 'App ID',
                spaceId: 'Space ID',
            },
        };
    }
    catch (error) {
        return { data: null };
    }
};
exports.default = hook;
