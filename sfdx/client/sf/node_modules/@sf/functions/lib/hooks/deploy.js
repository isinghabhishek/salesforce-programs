"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionsDeployer = exports.FunctionsDeployable = void 0;
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const color_1 = require("@heroku-cli/color");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const chalk_1 = require("chalk");
const debug_1 = require("debug");
const api_client_1 = require("../lib/api-client");
const git_1 = require("../lib/git");
const utils_1 = require("../lib/utils");
const function_reference_utils_1 = require("../lib/function-reference-utils");
const batch_call_1 = require("../lib/batch-call");
const debug = (0, debug_1.default)('deploy');
class FunctionsDeployable extends sf_plugins_core_1.Deployable {
    constructor(functionsDir, parent) {
        super();
        this.functionsDir = functionsDir;
        this.parent = parent;
    }
    getName() {
        return (0, path_1.basename)(this.functionsDir);
    }
    getType() {
        return 'function';
    }
    getPath() {
        return (0, path_1.basename)(this.functionsDir);
    }
    getParent() {
        return this.parent;
    }
}
exports.FunctionsDeployable = FunctionsDeployable;
class FunctionsDeployer extends sf_plugins_core_1.Deployer {
    constructor(functionsDir) {
        super();
        this.functionsDir = functionsDir;
        this.TOKEN_BEARER_KEY = 'functions-bearer';
        this.deployables = [new FunctionsDeployable(functionsDir, this)];
    }
    getName() {
        return FunctionsDeployer.NAME;
    }
    async setup(flags, options) {
        var _a;
        this.stateAggregator = await core_1.StateAggregator.getInstance();
        const apiKey = process.env.SALESFORCE_FUNCTIONS_API_KEY;
        if (apiKey) {
            this.auth = apiKey;
        }
        else {
            const token = (_a = this.stateAggregator.tokens.get(this.TOKEN_BEARER_KEY, true)) === null || _a === void 0 ? void 0 : _a.token;
            if (!token) {
                throw new Error('Not authenticated. Please login with `sf login functions`.');
            }
            this.auth = token;
        }
        this.client = new api_client_1.default({
            auth: this.auth,
            apiUrl: (0, api_client_1.herokuClientApiUrl)(),
        });
        // We pass the api token value to the Git constructor so that it will redact it from any of
        // the server logs
        const redactedToken = this.auth;
        this.git = new git_1.default([redactedToken !== null && redactedToken !== void 0 ? redactedToken : '']);
        if (flags.interactive) {
            this.username = await this.promptForUsername();
            this.branch = await this.promptForBranch();
            this.force = await this.promptForForce();
            this.quiet = await this.promptForQuiet();
        }
        else {
            this.username = options.username || (await this.promptForUsername());
            this.branch = options.branch || (await this.promptForBranch());
            this.force = typeof options.force === 'boolean' ? options.force : await this.promptForForce();
            this.quiet = typeof options.quiet === 'boolean' ? options.quiet : await this.promptForQuiet();
        }
        return {
            username: this.username,
            branch: this.branch,
            force: this.force,
            quiet: this.quiet,
        };
    }
    async deploy() {
        var _a, _b;
        this.log();
        this.log(`Deploying ${chalk_1.cyan.bold((0, path_1.basename)(this.functionsDir))}`);
        const flags = {
            'connected-org': this.username,
            branch: this.branch,
            force: this.force,
            quiet: this.quiet,
        };
        // We don't want to deploy anything if they've got work that hasn't been committed yet because
        // it could end up being really confusing since the user isn't calling git directly
        if (await this.git.hasUnpushedFiles()) {
            throw new Error('Your repo has files that have not been committed yet. Please either commit or stash them before deploying your project.');
        }
        // Heroku side: Fetch git remote URL and push working branch to Heroku git server
        console.log('Pushing changes to functions');
        const org = await (0, utils_1.fetchOrg)(flags['connected-org']);
        const project = await (0, utils_1.fetchSfdxProject)();
        // FunctionReferences: create function reference using info from function.toml and project info
        // we do this early on because we don't want to bother with anything else if it turns out
        // there are no functions to deploy
        const references = await (0, function_reference_utils_1.resolveFunctionReferences)(project);
        let app;
        try {
            app = await (0, utils_1.fetchAppForProject)(this.client, project.name, flags['connected-org']);
        }
        catch (err) {
            const error = err;
            if ((_a = error.body.message) === null || _a === void 0 ? void 0 : _a.includes("Couldn't find that app")) {
                throw new Error(`No compute environment found for org ${flags['connected-org']}. Please ensure you've created a compute environment before deploying.`);
            }
            throw error;
        }
        if (flags.force && ((_b = app.sales_org_connection) === null || _b === void 0 ? void 0 : _b.sales_org_stage) === 'prod') {
            throw new Error('You cannot use the force option with a production org.');
        }
        const remote = await this.git.getRemote(app, this.auth, this.username);
        debug('pushing to git server');
        const pushCommand = ['push', remote, `${flags.branch}:master`];
        // Since we error out if they try to use `--force` with a production org, we don't check for
        // a production org here since this code would be unreachable in that scenario
        if (flags.force) {
            pushCommand.push('--force');
        }
        try {
            await this.git.exec(pushCommand, flags.quiet);
        }
        catch (err) {
            const error = err;
            // if they've passed `--quiet` we don't want to show any build server output *unless* there's
            // an error, in which case we want to show all of it
            if (flags.quiet) {
                throw new Error(error.message.replace(this.auth || '', '<REDACTED>'));
            }
            // In this case, they have not passed `--quiet`, in which case we have already streamed
            // the entirety of the build server output and don't need to show it again
            throw new Error('There was an issue when deploying your functions.');
        }
        debug('pushing function references', references);
        const connection = org.getConnection();
        // Since the metadata upsert API can only handle 10 records at a time AND needs to run in sequence, we need to
        // make sure that we're only submitting 10 records at once and then waiting for that batch to complete before
        // submitting more
        const results = await (0, batch_call_1.default)(references, (chunk) => connection.metadata.upsert('FunctionReference', chunk));
        results.forEach((result) => {
            if (!result.success) {
                throw new Error(`Unable to deploy FunctionReference for ${result.fullName}.`);
            }
            if (!flags.quiet) {
                this.log(`Reference for ${result.fullName} ${result.created ? color_1.default.cyan('created') : color_1.default.green('updated')}`);
            }
        });
        // Remove any function references for functions that no longer exist
        const successfulReferences = results.reduce((acc, result) => {
            if (result.success) {
                acc.push((0, function_reference_utils_1.splitFullName)(result.fullName));
            }
            return acc;
        }, []);
        let refList = await connection.metadata.list({ type: 'FunctionReference' });
        refList = (0, function_reference_utils_1.ensureArray)(refList);
        const allReferences = refList.reduce((acc, ref) => {
            acc.push((0, function_reference_utils_1.splitFullName)(ref.fullName));
            return acc;
        }, []);
        const referencesToRemove = (0, function_reference_utils_1.filterProjectReferencesToRemove)(allReferences, successfulReferences, project.name);
        if (referencesToRemove.length) {
            this.log('Removing the following functions that were deleted locally:');
            referencesToRemove.forEach((ref) => {
                this.log(ref);
            });
            await (0, batch_call_1.default)(referencesToRemove, (chunk) => connection.metadata.delete('FunctionReference', chunk));
        }
    }
    async promptForUsername() {
        const { username } = await this.prompt([
            {
                name: 'username',
                message: 'Select the username or alias for the org that the compute environment should be connected to:',
                type: 'input',
            },
        ]);
        return username;
    }
    async promptForBranch() {
        const { prompt } = await this.prompt([
            {
                name: 'prompt',
                message: 'Would you like to deploy to a branch other than the currently active branch?',
                type: 'confirm',
            },
        ]);
        if (prompt) {
            const { branch } = await this.prompt([
                {
                    name: 'branch',
                    message: 'Are you sure you want to force push? Please use caution when force pushing.',
                    type: 'input',
                },
            ]);
            return branch;
        }
        else {
            return await this.git.getCurrentBranch();
        }
    }
    async promptForForce() {
        const { force } = await this.prompt([
            {
                name: 'force',
                message: 'Would you like to force push these changes to git?',
                type: 'confirm',
            },
        ]);
        if (force) {
            const { confirm } = await this.prompt([
                {
                    name: 'confirm',
                    message: 'Are you sure you want to force push? Please use caution when force pushing.',
                    type: 'confirm',
                },
            ]);
            return confirm;
        }
        else {
            return false;
        }
    }
    async promptForQuiet() {
        const { quiet } = await this.prompt([
            {
                name: 'quiet',
                message: 'Would you like to limit the amount of output displayed from the deploy process?',
                type: 'confirm',
            },
        ]);
        return quiet;
    }
}
exports.FunctionsDeployer = FunctionsDeployer;
FunctionsDeployer.NAME = 'Functions';
const hook = async function (options) {
    const project = await core_1.SfProject.resolve();
    const functionsPath = (0, path_1.join)(project.getPath(), 'functions');
    return [new FunctionsDeployer(functionsPath)];
};
exports.default = hook;
