"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const color_1 = require("@heroku-cli/color");
const core_1 = require("@salesforce/core");
const core_2 = require("@oclif/core");
const cli_ux_1 = require("cli-ux");
const flags_1 = require("../../../lib/flags");
const base_1 = require("../../../lib/base");
const utils_1 = require("../../../lib/utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-functions', 'env.var.unset');
class ConfigUnset extends base_1.default {
    async run() {
        var _a, _b, _c, _d;
        const { flags, argv } = await this.parse(ConfigUnset);
        this.postParseHook(flags);
        // We support both versions of the flag here for the sake of backward compat
        const targetCompute = (_a = flags['target-compute']) !== null && _a !== void 0 ? _a : flags.environment;
        if (!targetCompute) {
            throw new core_2.Errors.CLIError(`Missing required flag:
        -e, --target-compute TARGET-COMPUTE  ${color_1.default.dim('Environment name.')}
       See more help with --help`);
        }
        if (flags.environment) {
            this.warn(messages.getMessage('flags.environment.deprecation'));
        }
        if (argv.length === 0) {
            throw new core_2.Errors.CLIError('You must enter a config var key (i.e. mykey).');
        }
        const appName = await (0, utils_1.resolveAppNameForEnvironment)(targetCompute);
        try {
            const { data: config } = await this.client.get(`/apps/${appName}/config-vars`);
            const value = config[argv[0]];
            if (!value) {
                this.error('not correct config var', { exit: 401 });
            }
        }
        catch (e) {
            const error = e;
            if ((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes('not correct config var')) {
                this.error(new Error(`Value provided for key does not match a config var found for ${appName}`));
            }
            if ((_c = error.message) === null || _c === void 0 ? void 0 : _c.includes('404')) {
                this.error(new Error(`Couldn't find that app ${appName}`));
            }
            if ((_d = error.message) === null || _d === void 0 ? void 0 : _d.includes('401')) {
                this.error(new Error('Your token has expired, please login with sf login functions'));
            }
            this.error(error);
        }
        const configPairs = argv.reduce((acc, elem) => {
            return Object.assign(Object.assign({}, acc), { [elem]: null });
        }, {});
        const message = `Unsetting ${Object.keys(configPairs)
            .map((key) => color_1.default.configVar(key))
            .join(', ')} and restarting ${color_1.default.app(targetCompute)}`;
        cli_ux_1.cli.action.start(message);
        await this.client.patch(`/apps/${appName}/config-vars`, {
            data: configPairs,
        });
        cli_ux_1.cli.action.stop();
        return 'Unset env var';
    }
}
exports.default = ConfigUnset;
ConfigUnset.strict = false;
ConfigUnset.summary = messages.getMessage('summary');
ConfigUnset.description = messages.getMessage('description');
ConfigUnset.examples = messages.getMessages('examples');
ConfigUnset.flags = {
    'target-compute': flags_1.FunctionsFlagBuilder.environment({
        exclusive: ['environment'],
    }),
    environment: flags_1.FunctionsFlagBuilder.environment({
        char: 'e',
        exclusive: ['target-compute'],
        hidden: true,
    }),
};
