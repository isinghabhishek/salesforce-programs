"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const Transport = require("jsforce/lib/transport");
const cli_ux_1 = require("cli-ux");
const base_1 = require("../../../lib/base");
const heroku_variant_1 = require("../../../lib/heroku-variant");
const utils_1 = require("../../../lib/utils");
// This is a public Oauth client created expressly for the purpose of headless auth in the functions CLI.
// It does not require a client secret, is marked as public in the database and scoped accordingly
const PUBLIC_CLIENT_ID = '1e9cdca9-cec7-4dbf-ae84-408694b22bac';
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-functions', 'login.functions.jwt');
class JwtLogin extends base_1.default {
    async initAuthInfo(username, clientId, keyfile, loginUrl) {
        const oauth2OptionsBase = {
            clientId,
            privateKeyFile: keyfile,
        };
        if (!loginUrl) {
            const project = await (0, utils_1.fetchSfdxProject)();
            // If the user passes an instance URL, we always want to defer that over trying to read their
            // project config or defaulting to the basic salesforce login URL.
            loginUrl = (0, ts_types_1.getString)(project, 'sfdcLoginUrl', 'https://login.salesforce.com');
        }
        const oauth2Options = Object.assign(Object.assign({}, oauth2OptionsBase), { loginUrl });
        let authInfo;
        try {
            authInfo = await core_2.AuthInfo.create({
                username,
                oauth2Options,
            });
        }
        catch (err) {
            const error = err;
            if (error.name === 'AuthInfoOverwriteError') {
                const remover = await core_2.AuthRemover.create();
                await remover.removeAuth(username);
                authInfo = await core_2.AuthInfo.create({
                    username,
                    oauth2Options,
                });
            }
            else {
                this.error(error);
            }
        }
        await authInfo.save();
        return authInfo;
    }
    async run() {
        var _a, _b, _c, _d;
        const { flags } = await this.parse(JwtLogin);
        this.postParseHook(flags);
        const { clientid, username, keyfile } = flags;
        // We support both versions of the flag here for the sake of backward compat
        const instanceUrl = (_a = flags['instance-url']) !== null && _a !== void 0 ? _a : flags.instanceurl;
        if (flags.instanceurl) {
            this.warn(messages.getMessage('flags.instanceurl.deprecation'));
        }
        cli_ux_1.cli.action.start('Logging in via JWT');
        // Use keyfile, clientid, and username to auth with salesforce via the same workflow
        // as sfdx auth:jwt:grant --json
        const auth = await this.initAuthInfo(username, clientid, keyfile, instanceUrl);
        // Take care of any alias/default setting that needs to happen for the sfdx credential
        // before we move on to the heroku stuff
        if (flags.alias) {
            await auth.setAlias(flags.alias);
        }
        if (flags['set-default']) {
            await auth.setAsDefault({
                org: true,
            });
        }
        if (flags['set-default-dev-hub']) {
            await auth.setAsDefault({
                devHub: true,
            });
        }
        await auth.save();
        // Obtain sfdx access token from Auth info
        const authFields = auth.getFields(true);
        const token = authFields.accessToken;
        // Fire off request to /oauth/tokens on the heroku side with JWT in the payload and
        // obtain heroku access_token. This is configurable so that we can also target staging
        const herokuClientId = (_b = process.env.SALESFORCE_FUNCTIONS_PUBLIC_OAUTH_CLIENT_ID) !== null && _b !== void 0 ? _b : PUBLIC_CLIENT_ID;
        let rawResponse;
        try {
            rawResponse = await new Transport().httpRequest({
                method: 'POST',
                url: `${process.env.SALESFORCE_FUNCTIONS_API || 'https://api.heroku.com'}/oauth/tokens`,
                body: JSON.stringify({
                    client: {
                        id: herokuClientId,
                    },
                    grant: {
                        type: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    },
                    subject_token: token,
                    subject_token_type: 'urn:ietf:params:oauth:token-type:access_token',
                }),
                headers: Object.assign({}, (0, heroku_variant_1.herokuVariant)('salesforce_sso')),
            });
        }
        catch (e) {
            const error = e;
            if ((_c = error.message) === null || _c === void 0 ? void 0 : _c.includes('404')) {
                this.error('No functions connection');
            }
            if ((_d = error.message) === null || _d === void 0 ? void 0 : _d.includes('403')) {
                this.error('User has not been provisioned yet, try $ sf login functions');
            }
            this.error(error);
        }
        const data = JSON.parse(rawResponse.body);
        const bearerToken = data.access_token.token;
        // We have to blow away the auth and API client objects so that they'll fully reinitialize with
        // the new heroku credentials we're about to generate
        this.resetClientAuth();
        this.stateAggregator.tokens.set(base_1.default.TOKEN_BEARER_KEY, {
            token: bearerToken,
            url: this.identityUrl.toString(),
            user: auth.getUsername(),
        });
        await this.stateAggregator.tokens.write();
        cli_ux_1.cli.action.stop();
        return {
            username: authFields.username,
            sfdxAccessToken: token,
            functionsAccessToken: bearerToken,
            instanceUrl: authFields.instanceUrl,
            orgId: authFields.orgId,
            privateKey: authFields.privateKey,
        };
    }
}
exports.default = JwtLogin;
JwtLogin.summary = messages.getMessage('summary');
JwtLogin.description = messages.getMessage('description');
JwtLogin.examples = messages.getMessages('examples');
JwtLogin.flags = {
    username: core_1.Flags.string({
        required: true,
        description: messages.getMessage('flags.username.summary'),
        char: 'u',
    }),
    keyfile: core_1.Flags.string({
        required: true,
        char: 'f',
        description: messages.getMessage('flags.keyfile.summary'),
    }),
    clientid: core_1.Flags.string({
        required: true,
        char: 'i',
        description: messages.getMessage('flags.clientid.summary'),
    }),
    'instance-url': core_1.Flags.string({
        char: 'l',
        description: messages.getMessage('flags.instance-url.summary'),
        exclusive: ['instanceurl'],
    }),
    instanceurl: core_1.Flags.string({
        char: 'l',
        description: messages.getMessage('flags.instance-url.summary'),
        exclusive: ['instance-url'],
        hidden: true,
    }),
    alias: core_1.Flags.string({
        char: 'a',
        description: messages.getMessage('flags.alias.summary'),
    }),
    'set-default': core_1.Flags.boolean({
        char: 'd',
        description: messages.getMessage('flags.set-default.summary'),
    }),
    'set-default-dev-hub': core_1.Flags.boolean({
        char: 'v',
        description: messages.getMessage('flags.set-default-dev-hub.summary'),
    }),
};
