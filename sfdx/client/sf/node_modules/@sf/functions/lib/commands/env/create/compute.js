"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const color_1 = require("@heroku-cli/color");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const cli_ux_1 = require("cli-ux");
const base_1 = require("../../../lib/base");
const flags_1 = require("../../../lib/flags");
const poll_for_result_1 = require("../../../lib/poll-for-result");
const utils_1 = require("../../../lib/utils");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-functions', 'env.create.compute');
class EnvCreateCompute extends base_1.default {
    async run() {
        var _a, _b, _c, _d;
        const { flags } = await this.parse(EnvCreateCompute);
        this.postParseHook(flags);
        const alias = flags.alias;
        // if `--connected-org` is null here, fetchOrg will pull the default org from the surrounding environment
        const org = await (0, utils_1.fetchOrg)(flags['connected-org']);
        const orgId = org.getOrgId();
        if (!(await this.isFunctionsEnabled(org))) {
            this.error(`The org you are attempting to create a compute environment for does not have the ${color_1.default.green('Functions')} feature enabled.\n` +
                '\n' +
                'Before you can create a compute environment, please:\n' +
                '1. Enable Functions in your DevHub org\n' +
                `2. Add ${color_1.default.green('Functions')} to the "features" list in your scratch org definition JSON file, e.g. "features": ["Functions"]`);
        }
        cli_ux_1.cli.action.start(`Creating compute environment for org ID ${orgId}`);
        const project = await (0, utils_1.fetchSfdxProject)();
        const projectName = project.name;
        if (!projectName) {
            this.error('No project name found in sfdx-project.json.');
        }
        const connection = org.getConnection();
        await (0, poll_for_result_1.default)(async () => {
            // This query allows us to verify that the org connection has actually been created before
            // attempting to create a compute environment. If we don't wait for this to happen, environment
            // creation will fail since Heroku doesn't yet know about the org
            let response;
            try {
                response = await connection.query(`SELECT
          Id,
          Status,
          Error
          FROM FunctionsConnection`);
            }
            catch (err) {
                const error = err;
                // This is obviously heinous, but should only exist short-term until the move from `FunctionsConnection`
                // to `FunctionConnection` is complete. Once that's done, we can remove this and go back to a simple
                // query against `FunctionConnection`
                if (!error.message.includes("sObject type 'FunctionsConnection' is not supported.")) {
                    this.error(error);
                }
                response = await connection.query(`SELECT
            Id,
            Status,
            Error
            FROM FunctionConnection`);
            }
            // If it's a newly created org, we likely won't get anything back for the first few iterations,
            // we keep polling
            if (!response.records.length) {
                return false;
            }
            const record = response.records[0];
            // This error is also expected when working with a newly created org. This error just means
            // that the devhub hasn't yet enabled functions on the new org (this is an automated async process
            // so it takes a bit of time)
            if (record.Error === 'Enable Salesforce Functions from Setup Page') {
                return false;
            }
            // If there is any other error besides the one mentioned above, something is actually wrong
            // and we should bail
            if (record.Error) {
                this.error(`${record.Error}`);
            }
            // This is the go signal. Once we have this status it means that the connection is fully up
            // and running, and we are good to create a compute environment.
            return record.Status === 'TrustedBiDirection';
        });
        try {
            const { data: app } = await this.client.post(`/sales-org-connections/${orgId}/apps`, {
                headers: {
                    Accept: 'application/vnd.heroku+json; version=3.evergreen',
                },
                data: {
                    sfdx_project_name: projectName,
                },
            });
            cli_ux_1.cli.action.stop();
            this.log(`New compute environment created with ID ${app.name}`);
            cli_ux_1.cli.action.start('Connecting environments');
            if (alias) {
                this.stateAggregator.aliases.set(alias, app.id);
                await this.stateAggregator.aliases.write();
            }
            cli_ux_1.cli.action.stop();
            this.log(alias
                ? `Your compute environment with local alias ${color_1.default.cyan(alias)} is ready.`
                : 'Your compute environment is ready.');
        }
        catch (err) {
            const DUPLICATE_PROJECT_MESSAGE = 'There is already a project with the same name in the same namespace for this org';
            const INVALID_PROJECT_NAME = "Sfdx project name may only contain numbers (0-9), letters (a-z A-Z) and non-consecutive underscores ('_'). It must begin with a letter and end with either a number or letter.";
            const error = err;
            cli_ux_1.cli.action.stop('error!');
            if ((_b = (_a = error.data) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(INVALID_PROJECT_NAME)) {
                this.error("Project name may only contain numbers (0-9), letters (a-z A-Z) and non-consecutive underscores ('_'). It must begin with a letter and end with either a number or letter");
            }
            // If environment creation fails because an environment already exists for this org and project
            // we want to fetch the existing environment so that we can point the user to it
            if ((_d = (_c = error.data) === null || _c === void 0 ? void 0 : _c.message) === null || _d === void 0 ? void 0 : _d.includes(DUPLICATE_PROJECT_MESSAGE)) {
                const app = await (0, utils_1.fetchAppForProject)(this.client, projectName, org.getUsername());
                this.error(`This org is already connected to a compute environment for this project -> ${app.name}`);
            }
            this.error(`${error.data.message}`);
        }
        const app = await (0, utils_1.fetchAppForProject)(this.client, projectName, org.getUsername());
        return {
            alias,
            projectName,
            connectedOrgAlias: '',
            connectedOrgId: orgId,
            computeEnvironmentName: app.name,
        };
    }
}
exports.default = EnvCreateCompute;
EnvCreateCompute.summary = messages.getMessage('summary');
EnvCreateCompute.description = messages.getMessage('description');
EnvCreateCompute.examples = messages.getMessages('examples');
EnvCreateCompute.flags = {
    'connected-org': flags_1.FunctionsFlagBuilder.connectedOrg(),
    alias: core_1.Flags.string({
        char: 'a',
        description: messages.getMessage('flags.alias.summary'),
    }),
};
