"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const color_1 = require("@heroku-cli/color");
const core_1 = require("@salesforce/core");
const cli_ux_1 = require("cli-ux");
const core_2 = require("@oclif/core");
const function_reference_utils_1 = require("../../lib/function-reference-utils");
const flags_1 = require("../../lib/flags");
const base_1 = require("../../lib/base");
const batch_call_1 = require("../../lib/batch-call");
const utils_1 = require("../../lib/utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-functions', 'env.delete');
class EnvDelete extends base_1.default {
    async run() {
        var _a, _b;
        const { flags } = await this.parse(EnvDelete);
        this.postParseHook(flags);
        // We support both versions of the flag here for the sake of backward compat
        const targetCompute = (_a = flags['target-compute']) !== null && _a !== void 0 ? _a : flags.environment;
        if (!targetCompute) {
            throw new core_2.Errors.CLIError(`Missing required flag:
        -e, --target-compute TARGET-COMPUTE  ${color_1.default.dim('Environment name.')}
       See more help with --help`);
        }
        if (flags.environment) {
            this.warn(messages.getMessage('flags.environment.deprecation'));
        }
        await this.confirmRemovePrompt('environment', targetCompute, flags.confirm);
        cli_ux_1.cli.action.start(`Deleting environment ${targetCompute}`);
        if (targetCompute) {
            try {
                // If we are able to successfully create a Salesforce org, then this name does not refer to a compute environment.
                // Regardless of what happens, this block will result in an error.
                const org = await core_1.Org.create({ aliasOrUsername: targetCompute });
                if (org) {
                    throw new Error(`The environment ${color_1.default.cyan(targetCompute)} is a Salesforce org. The env:delete command currently can only be used to delete compute environments. Please use sfdx force:org:delete to delete scratch and sandbox Salesforce org environments.`);
                }
            }
            catch (err) {
                const error = err;
                // If the error is the one we throw above, then we will send the error to the user.
                // If not (meaning the environment name provided might be a compute environment) then we swallow the error and proceed.
                if (error.message.includes(`The environment ${color_1.default.cyan(targetCompute)} is a Salesforce org.`)) {
                    this.error(error);
                }
            }
        }
        // Check if the environment provided is an alias or not, to determine what app name we use to attempt deletion
        const appName = await (0, utils_1.resolveAppNameForEnvironment)(targetCompute);
        let app;
        try {
            // If app exists, it will be deleted
            const response = await this.client.get(`/apps/${appName}`, {
                headers: {
                    Accept: 'application/vnd.heroku+json; version=3.evergreen',
                },
            });
            app = response.data;
        }
        catch (error) {
            // App with name does not exist
            this.error(new Error('Value provided for environment does not match a compute environment name or an alias to a compute environment.'));
        }
        let connectedOrg = null;
        try {
            connectedOrg = await (0, utils_1.resolveOrg)((_b = app === null || app === void 0 ? void 0 : app.sales_org_connection) === null || _b === void 0 ? void 0 : _b.sales_org_id);
        }
        catch (err) {
            const error = err;
            // It's possible that they are deleting the compute environment after deleting the org it was
            // connected to, in which case `resolveOrg` will error and we simply want to skip the process
            // of cleaning up functon refs since they're all already gone. Otherwise, something else has
            // gone wrong and we go ahead and bail out.
            if (error.message !== 'Attempted to resolve an org without a valid org ID') {
                this.error(error);
            }
        }
        // If we are actually able to resolve an Org instance, it means they are deleting the compute
        // environment while the org still exists, so we need to delete all the function references
        // from the org as part of the cleanup process
        if (connectedOrg) {
            const orgId = connectedOrg.getOrgId();
            const isExpired = await (0, utils_1.findOrgExpirationStatus)(orgId);
            if (!isExpired) {
                const project = await (0, utils_1.fetchSfdxProject)();
                const connection = connectedOrg.getConnection();
                let refList = await connection.metadata.list({ type: 'FunctionReference' });
                refList = (0, function_reference_utils_1.ensureArray)(refList);
                if (refList && refList.length) {
                    const allReferences = refList.reduce((acc, ref) => {
                        acc.push((0, function_reference_utils_1.splitFullName)(ref.fullName));
                        return acc;
                    }, []);
                    const referencesToRemove = (0, function_reference_utils_1.filterProjectReferencesToRemove)(allReferences, [], project.name);
                    await (0, batch_call_1.default)(referencesToRemove, (chunk) => connection.metadata.delete('FunctionReference', chunk));
                }
            }
        }
        // Delete the application
        await this.client.delete(`/apps/${appName}`, {
            headers: {
                Accept: 'application/vnd.heroku+json; version=3.evergreen',
            },
        });
        cli_ux_1.cli.action.stop();
        return 'Environment deleted.';
    }
}
exports.default = EnvDelete;
EnvDelete.summary = messages.getMessage('summary');
EnvDelete.description = messages.getMessage('description');
EnvDelete.examples = messages.getMessages('examples');
EnvDelete.flags = {
    'target-compute': flags_1.FunctionsFlagBuilder.environment({
        exclusive: ['environment'],
    }),
    environment: flags_1.FunctionsFlagBuilder.environment({
        char: 'e',
        exclusive: ['target-compute'],
        hidden: true,
    }),
    confirm: flags_1.confirmationFlag,
};
