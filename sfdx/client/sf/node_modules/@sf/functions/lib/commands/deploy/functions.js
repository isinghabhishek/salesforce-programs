"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const color_1 = require("@heroku-cli/color");
const core_1 = require("@salesforce/core");
const core_2 = require("@oclif/core");
const cli_ux_1 = require("cli-ux");
const debug_1 = require("debug");
const base_1 = require("../../lib/base");
const batch_call_1 = require("../../lib/batch-call");
const flags_1 = require("../../lib/flags");
const function_reference_utils_1 = require("../../lib/function-reference-utils");
const git_1 = require("../../lib/git");
const utils_1 = require("../../lib/utils");
const debug = (0, debug_1.default)('deploy:functions');
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-functions', 'project.deploy.functions');
class DeployFunctions extends base_1.default {
    async run() {
        var _a, _b, _c;
        const { flags } = await this.parse(DeployFunctions);
        this.postParseHook(flags);
        // We pass the api token value to the Git constructor so that it will redact it from any of
        // the server logs
        const redactedToken = this.auth;
        this.git = new git_1.default([redactedToken !== null && redactedToken !== void 0 ? redactedToken : '']);
        // We don't want to deploy anything if they've got work that hasn't been committed yet because
        // it could end up being really confusing since the user isn't calling git directly
        if (await this.git.hasUnpushedFiles()) {
            this.error('Your repo has files that have not been committed yet. Please either commit or stash them before deploying your project.');
        }
        // Heroku side: Fetch git remote URL and push working branch to Heroku git server
        cli_ux_1.cli.action.start('Pushing changes to functions');
        const org = await (0, utils_1.fetchOrg)(flags['connected-org']);
        const project = await (0, utils_1.fetchSfdxProject)();
        // FunctionReferences: create function reference using info from function.toml and project info
        // we do this early on because we don't want to bother with anything else if it turns out
        // there are no functions to deploy
        const references = await (0, function_reference_utils_1.resolveFunctionReferences)(project);
        let app;
        try {
            app = await (0, utils_1.fetchAppForProject)(this.client, project.name, flags['connected-org']);
        }
        catch (error) {
            if ((_b = (_a = error.body) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes("Couldn't find that app")) {
                this.error(`No compute environment found for org ${flags['connected-org']}. Please ensure you've created a compute environment before deploying.`);
            }
            throw error;
        }
        if (flags.force && ((_c = app.sales_org_connection) === null || _c === void 0 ? void 0 : _c.sales_org_stage) === 'prod') {
            this.error('You cannot use the `--force` flag with a production org.');
        }
        const remote = await this.git.getRemote(app, redactedToken, this.username);
        debug('pushing to git server');
        const currentBranch = await this.git.getCurrentBranch();
        const pushCommand = ['push', remote, `${flags.branch || currentBranch}:master`];
        // Since we error out if they try to use `--force` with a production org, we don't check for
        // a production org here since this code would be unreachable in that scenario
        if (flags.force) {
            pushCommand.push('--force');
        }
        try {
            await this.git.exec(pushCommand, flags.quiet);
        }
        catch (err) {
            const error = err;
            // if they've passed `--quiet` we don't want to show any build server output *unless* there's
            // an error, in which case we want to show all of it
            if (flags.quiet) {
                this.error(error.message.replace(redactedToken, '<REDACTED>'));
            }
            // In this case, they have not passed `--quiet`, in which case we have already streamed
            // the entirety of the build server output and don't need to show it again
            this.error('There was an issue when deploying your functions.');
        }
        debug('pushing function references', references);
        const connection = org.getConnection();
        let shouldExitNonZero = false;
        // Since the metadata upsert API can only handle 10 records at a time AND needs to run in sequence, we need to
        // make sure that we're only submitting 10 records at once and then waiting for that batch to complete before
        // submitting more
        const results = await (0, batch_call_1.default)(references, (chunk) => connection.metadata.upsert('FunctionReference', chunk));
        results.forEach((result) => {
            if (!result.success) {
                shouldExitNonZero = true;
                cli_ux_1.cli.error(`Unable to deploy FunctionReference for ${result.fullName}.`, { exit: false });
            }
            if (!flags.quiet && !flags.json) {
                this.log(`Reference for ${result.fullName} ${result.created ? color_1.default.cyan('created') : color_1.default.green('updated')}`);
            }
        });
        // Remove any function references for functions that no longer exist
        const successfulReferences = results.reduce((acc, result) => {
            if (result.success) {
                acc.push((0, function_reference_utils_1.splitFullName)(result.fullName));
            }
            return acc;
        }, []);
        let refList = await connection.metadata.list({ type: 'FunctionReference' });
        refList = (0, function_reference_utils_1.ensureArray)(refList);
        const allReferences = refList.reduce((acc, ref) => {
            acc.push((0, function_reference_utils_1.splitFullName)(ref.fullName));
            return acc;
        }, []);
        const referencesToRemove = (0, function_reference_utils_1.filterProjectReferencesToRemove)(allReferences, successfulReferences, project.name);
        if (referencesToRemove.length) {
            this.log('Removing the following functions that were deleted locally:');
            referencesToRemove.forEach((ref) => {
                this.log(ref);
            });
            await (0, batch_call_1.default)(referencesToRemove, (chunk) => connection.metadata.delete('FunctionReference', chunk));
        }
        cli_ux_1.cli.action.stop();
        if (shouldExitNonZero) {
            this.exit(1);
        }
        return results;
    }
}
exports.default = DeployFunctions;
DeployFunctions.summary = messages.getMessage('summary');
DeployFunctions.description = messages.getMessage('description');
DeployFunctions.examples = messages.getMessages('examples');
DeployFunctions.flags = {
    'connected-org': flags_1.FunctionsFlagBuilder.connectedOrg({
        required: true,
    }),
    branch: core_2.Flags.string({
        char: 'b',
        description: messages.getMessage('flags.branch.summary'),
    }),
    force: core_2.Flags.boolean({
        description: messages.getMessage('flags.force.summary'),
    }),
    quiet: core_2.Flags.boolean({
        description: messages.getMessage('flags.quiet.summary'),
        char: 'q',
    }),
};
