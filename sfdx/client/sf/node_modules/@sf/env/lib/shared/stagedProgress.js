"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StagedProgress = exports.StateConstants = exports.State = exports.boldPurple = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const chalk = require("chalk");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const compareStages = ([, aValue], [, bValue]) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return aValue.index - bValue.index;
};
exports.boldPurple = chalk.rgb(157, 129, 221).bold;
var State;
(function (State) {
    State["inProgress"] = "inProgress";
    State["completed"] = "completed";
    State["failed"] = "failed";
    State["unknown"] = "unknown";
})(State = exports.State || (exports.State = {}));
exports.StateConstants = {
    inProgress: { color: exports.boldPurple, char: '…', visited: false, state: State.inProgress },
    completed: { color: sf_plugins_core_1.StandardColors.success, char: '✓', visited: false, state: State.completed },
    failed: { color: chalk.bold.red, char: '✖', visited: false, state: State.failed },
    unknown: { color: chalk.dim, char: '…', visited: false, state: State.unknown },
};
class StagedProgress {
    constructor(stages) {
        this.theStages = stages
            .map((stage, index) => {
            return {
                [stage]: { ...exports.StateConstants[State.unknown], index: (index + 1) * 10 },
            };
        })
            .reduce((m, b) => Object.assign(m, b), {});
    }
    get statusData() {
        return this.dataForTheStatus;
    }
    set statusData(statusData) {
        this.dataForTheStatus = statusData;
    }
    formatStages() {
        return Object.entries(this.theStages)
            .sort(compareStages)
            .map(([stage, stageState]) => {
            return stageState.color(`${stageState.char} - ${stage}`);
        })
            .join(os.EOL);
    }
    transitionStages(currentStage, newState) {
        currentStage = this.mapCurrentStage(currentStage);
        if (this.previousStage && this.previousStage !== currentStage) {
            this.updateStages(this.previousStage, State.completed);
        }
        // mark all previous stages as visited and completed
        this.markPreviousStagesAsCompleted(currentStage);
        this.previousStage = currentStage;
        this.currentStage = currentStage;
        this.updateStages(currentStage, newState);
    }
    markPreviousStagesAsCompleted(currentStage) {
        currentStage = this.mapCurrentStage(currentStage);
        Object.entries(this.theStages).forEach(([stage, stageState]) => {
            if (!currentStage || stageState.index < this.theStages[currentStage].index) {
                this.updateStages(stage, State.completed);
            }
        });
    }
    updateCurrentStage(newState) {
        this.updateStages(this.currentStage, newState);
    }
    updateStages(currentStage, newState) {
        currentStage = this.mapCurrentStage(currentStage);
        if (!this.theStages[currentStage]) {
            const sortedEntries = Object.entries(this.theStages).sort(compareStages);
            const visitedEntries = sortedEntries.filter(([, stageState]) => stageState.visited);
            const [, lastState] = visitedEntries.length
                ? visitedEntries[visitedEntries.length - 1]
                : ['', { state: exports.StateConstants.unknown.state, index: 0, visited: true }];
            const newEntry = {
                [currentStage]: { state: exports.StateConstants.unknown.state, visited: true, index: lastState.index + 1 },
            };
            this.theStages = Object.assign(this.theStages, newEntry);
        }
        this.theStages[currentStage].visited = true;
        this.theStages[currentStage].state = newState || State.inProgress;
        this.theStages[currentStage].char = exports.StateConstants[this.theStages[currentStage].state].char;
        this.theStages[currentStage].color = exports.StateConstants[newState.toString()].color;
    }
    getStages() {
        return this.theStages;
    }
    mapCurrentStage(currentStage) {
        return currentStage;
    }
}
exports.StagedProgress = StagedProgress;
//# sourceMappingURL=stagedProgress.js.map