"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const core_1 = require("@oclif/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_2 = require("@salesforce/core");
const open = require("open");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-env', 'open');
class EnvOpen extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(EnvOpen);
        const nameOrAlias = flags['target-env'];
        let url;
        if (!nameOrAlias) {
            // TODO this should be retrieved from sf config once we have those commands. If not found, still throw.
            throw messages.createError('error.NoDefaultEnv');
        }
        try {
            const org = await core_2.Org.create({ aliasOrUsername: nameOrAlias });
            const conn = org.getConnection();
            await org.refreshAuth();
            const authInfo = conn.getAuthInfo();
            url = authInfo.getOrgFrontDoorUrl();
        }
        catch (err) {
            if (err instanceof Error && err.name !== 'NamedOrgNotFoundError' && err.name !== 'AuthInfoCreationError') {
                throw err;
            }
            /* Expected - Do nothing */
        }
        if (!url) {
            throw messages.createError('error.NoEnvFound', [nameOrAlias]);
        }
        if (url) {
            if (flags.path) {
                const frontDoorUrl = new url_1.URL(url);
                frontDoorUrl.searchParams.append('retURL', flags.path);
                url = frontDoorUrl.toString();
            }
            if (flags['url-only']) {
                this.logSensitive(url);
            }
            else {
                const browser = flags.browser;
                const browserName = browser ? browser : 'the default browser';
                await this.open(url, browser);
                this.logSuccess(`Opening ${nameOrAlias} in ${browserName}.`);
            }
        }
        else {
            throw messages.createError('error.EnvironmentNotSupported', [nameOrAlias]);
        }
        return { url };
    }
    // TODO login and env open should probably share the same open code. Maybe we should use cli-ux.open?
    async open(url, browser) {
        let options;
        if (browser) {
            if (browser?.toLowerCase().includes('chrome')) {
                browser = open.apps.chrome;
            }
            if (browser?.toLowerCase().includes('firefox')) {
                browser = open.apps.firefox;
            }
            if (browser?.toLowerCase().includes('edge')) {
                browser = open.apps.edge;
            }
            options = { app: { name: browser } };
        }
        const chunks = [];
        const process = await open(url, options);
        return new Promise((resolve, reject) => {
            process.stderr.on('data', (chunk) => {
                chunks.push(Buffer.from(chunk));
            });
            const resolveOrReject = (code) => {
                // stderr could contain warnings or random data, so we will only error if we know there is a valid error.
                const validErrors = [
                    'Unable to find application named',
                    'InvalidOperationException',
                    'cannot find file',
                    'cannot be run',
                ];
                const errorMessage = Buffer.concat(chunks).toString('utf8');
                if (code > 0 || validErrors.find((error) => errorMessage.includes(error))) {
                    core_2.Logger.childFromRoot('open').debug(errorMessage);
                    reject(messages.createError('error.ApplicationNotFound', [browser]));
                }
                else {
                    resolve();
                }
            };
            // This never seems to fire.
            process.once('error', (err) => reject(new core_2.SfdxError(err.message, 'OpenError')));
            // These are sometimes not fired (non-deterministic) for whatever reason, especially on windows. We will just rely on known errors in stderr.
            // It could be because of See https://github.com/sindresorhus/open/issues/144 but hacking around the open library didn't
            // seem to fix it.
            // process.once('close', resolveOrReject);
            // process.once('exit', resolveOrReject);
            // Nothing is ever printed to stdout, but we really only care about stderr.
            process.stderr.once('close', resolveOrReject);
        });
    }
}
exports.default = EnvOpen;
EnvOpen.summary = messages.getMessage('summary');
EnvOpen.description = messages.getMessage('description');
EnvOpen.examples = messages.getMessages('examples');
EnvOpen.flags = {
    path: core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.path.summary'),
    }),
    'url-only': core_1.Flags.boolean({
        char: 'r',
        summary: messages.getMessage('flags.url-only.summary'),
    }),
    'target-env': core_1.Flags.string({
        char: 'e',
        summary: messages.getMessage('flags.target-env.summary'),
        description: messages.getMessage('flags.target-env.description'),
    }),
    browser: core_1.Flags.string({
        summary: messages.getMessage('flags.browser.summary'),
        description: messages.getMessage('flags.browser.description'),
    }),
};
//# sourceMappingURL=open.js.map