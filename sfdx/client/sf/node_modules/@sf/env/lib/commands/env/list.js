"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const utils_1 = require("../../utils");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-env', 'list');
const envTypeValues = Object.keys(sf_plugins_core_1.EnvList.EnvType);
const envOrderBy = (a, b) => {
    // both a && b are well known
    if (envTypeValues.includes(a.type) && envTypeValues.includes(a.type)) {
        if (a.type === sf_plugins_core_1.EnvList.EnvType.salesforceOrgs && b.type !== sf_plugins_core_1.EnvList.EnvType.salesforceOrgs)
            return -1;
        if (a.type !== sf_plugins_core_1.EnvList.EnvType.salesforceOrgs && b.type === sf_plugins_core_1.EnvList.EnvType.salesforceOrgs)
            return 1;
        if (a.type === sf_plugins_core_1.EnvList.EnvType.scratchOrgs && b.type !== sf_plugins_core_1.EnvList.EnvType.scratchOrgs)
            return -1;
        return 1;
    }
    // both a && b are user defined - use natural sort
    if (!envTypeValues.includes(a.type) && !envTypeValues.includes(a.type)) {
        return a.type.localeCompare(b.type);
    }
    // well known always come before user defined
    if (envTypeValues.includes(a.type))
        return -1;
    return 1;
};
const buildColumns = (table) => {
    return table.data.flatMap(Object.keys).reduce((x, y) => {
        if (x[y])
            return x;
        const columnEntry = {
            header: (0, utils_1.toKey)(y, table.keys),
            get: (v) => (0, utils_1.toValue)(v[y]),
        };
        return { ...x, [y]: columnEntry };
    }, {});
};
class EnvList extends sf_plugins_core_1.SfCommand {
    async run() {
        this.flags = (await this.parse(EnvList)).flags;
        const tableOpts = {
            columns: this.flags.columns?.join(','),
            csv: this.flags.csv,
            filter: this.flags.filter,
            'no-header': this.flags['no-header'],
            'no-truncate': this.flags['no-truncate'],
            output: this.flags.output,
            sort: this.flags.sort,
        };
        let final = {};
        const results = await sf_plugins_core_1.SfHook.run(this.config, 'sf:env:list', { all: this.flags.all });
        const tables = results.successes
            .map((r) => r.result)
            .reduce((x, y) => x.concat(y), [])
            .filter((t) => t.data.length > 0)
            .sort(envOrderBy);
        if (tables.length === 0) {
            this.log(messages.getMessage('error.NoResultsFound'));
            return {};
        }
        else {
            for (const table of tables) {
                final = { ...final, ...{ [table.type]: table.data } };
                const columns = buildColumns(table);
                if (this.checkTableForNamedColumns(columns)) {
                    this.table(table.data, columns, { ...tableOpts, title: table.title });
                    this.log();
                }
                else {
                    this.warn(messages.getMessage('warning.RequestedColumnsNotPresentInEnvironment', [tableOpts.columns, table.title]));
                }
            }
        }
        return final;
    }
    checkTableForNamedColumns(columns) {
        return Object.entries(columns).some(([, value]) => {
            if (this.flags?.columns) {
                return this.flags?.columns.includes(value['header']);
            }
            return true;
        });
    }
}
exports.default = EnvList;
EnvList.summary = messages.getMessage('summary');
EnvList.description = messages.getMessage('description');
EnvList.examples = messages.getMessages('examples');
EnvList.flags = {
    all: core_1.Flags.boolean({
        summary: messages.getMessage('flags.all.summary'),
        char: 'a',
    }),
    columns: core_1.Flags.string({
        summary: messages.getMessage('flags.columns.summary'),
        multiple: true,
    }),
    csv: core_1.Flags.boolean({
        summary: messages.getMessage('flags.csv.summary'),
    }),
    filter: core_1.Flags.string({
        summary: messages.getMessage('flags.filter.summary'),
    }),
    'no-header': core_1.Flags.boolean({
        summary: messages.getMessage('flags.no-header.summary'),
    }),
    'no-truncate': core_1.Flags.boolean({
        summary: messages.getMessage('flags.no-truncate.summary'),
    }),
    output: core_1.Flags.string({
        summary: messages.getMessage('flags.output.summary'),
        options: ['csv', 'json', 'yaml'],
    }),
    sort: core_1.Flags.string({
        summary: messages.getMessage('flags.sort.summary'),
    }),
};
//# sourceMappingURL=list.js.map