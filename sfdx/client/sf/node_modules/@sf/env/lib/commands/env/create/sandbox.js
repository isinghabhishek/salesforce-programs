"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxLicenseType = void 0;
const fs = require("fs");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const sandboxCommandBase_1 = require("../../../shared/sandboxCommandBase");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-env', 'create.sandbox');
var SandboxLicenseType;
(function (SandboxLicenseType) {
    SandboxLicenseType["developer"] = "Developer";
    SandboxLicenseType["developerPro"] = "Developer_Pro";
    SandboxLicenseType["partial"] = "Partial";
    SandboxLicenseType["full"] = "Full";
})(SandboxLicenseType = exports.SandboxLicenseType || (exports.SandboxLicenseType = {}));
const getLicenseTypes = () => Object.values(SandboxLicenseType);
class CreateSandbox extends sandboxCommandBase_1.SandboxCommandBase {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['postorgcreate'];
    }
    async run() {
        this.sandboxRequestConfig = await this.getSandboxRequestConfig();
        this.flags = (await this.parse(CreateSandbox)).flags;
        this.debug('Create started with args %s ', this.flags);
        this.validateFlags();
        return await this.createSandbox();
    }
    getCheckSandboxStatusParams() {
        return [this.latestSandboxProgressObj.Id, this.flags['target-org'].getUsername()];
    }
    lowerToUpper(object) {
        return Object.fromEntries(Object.entries(object).map(([k, v]) => [`${k.charAt(0).toUpperCase()}${k.slice(1)}`, v]));
    }
    async createSandboxRequest(prodOrg) {
        let sandboxDefFileContents = this.readJsonDefFile() || {};
        if (sandboxDefFileContents) {
            sandboxDefFileContents = this.lowerToUpper(sandboxDefFileContents);
        }
        // build sandbox request from data provided
        const sandboxReq = {
            SandboxName: undefined,
            ...sandboxDefFileContents,
            ...Object.assign({}, this.flags.name ? { SandboxName: this.flags.name } : {}),
            ...Object.assign({}, sandboxDefFileContents['LicenseType']
                ? { LicenseType: sandboxDefFileContents['LicenseType'] }
                : { LicenseType: this.flags['license-type'] }),
        };
        if (!sandboxReq.SandboxName) {
            // sandbox names are 10 chars or less, a radix of 36 = [a-z][0-9]
            // see https://help.salesforce.com/s/articleView?id=sf.data_sandbox_create.htm&type=5 for sandbox naming criteria
            // technically without querying the production org, the generated name could already exist,
            // but the chances of that are lower than the perf penalty of querying and verifying
            sandboxReq.SandboxName = `sbx${Date.now().toString(36).slice(-7)}`;
            this.info(messages.createWarning('warning.NoSandboxNameDefined', [sandboxReq.SandboxName]));
        }
        const sourceId = await this.getSourceId(prodOrg);
        if (sourceId) {
            sandboxReq.SourceId = sourceId;
            delete sandboxReq.LicenseType;
        }
        return sandboxReq;
    }
    async createSandbox() {
        this.prodOrg = this.flags['target-org'];
        const lifecycle = core_1.Lifecycle.getInstance();
        this.registerLifecycleListeners(lifecycle, {
            isAsync: this.flags.async,
            setDefault: this.flags['set-default'],
            alias: this.flags.alias,
            prodOrg: this.prodOrg,
            tracksSource: this.flags['no-track-source'] === true ? false : undefined,
        });
        const sandboxReq = await this.createSandboxRequest(this.prodOrg);
        await this.confirmSandboxReq({ ...sandboxReq, ...(this.flags.clone ? { CloneSource: this.flags.clone } : {}) });
        this.initSandboxProcessData(this.prodOrg, sandboxReq);
        if (!this.flags.async) {
            this.spinner.start('Sandbox Create');
        }
        this.debug('Calling create with SandboxRequest: %s ', sandboxReq);
        try {
            const sandboxProcessObject = await this.prodOrg.createSandbox(sandboxReq, {
                wait: this.flags.wait,
                interval: this.flags['poll-interval'],
                async: this.flags.async,
            });
            this.latestSandboxProgressObj = sandboxProcessObject;
            this.saveSandboxProgressConfig();
            if (this.flags.async) {
                process.exitCode = 68;
            }
            return sandboxProcessObject;
        }
        catch (err) {
            this.spinner.stop();
            const error = err;
            if (this.pollingTimeOut) {
                void lifecycle.emit(core_1.SandboxEvents.EVENT_ASYNC_RESULT, undefined);
                process.exitCode = 68;
                return this.latestSandboxProgressObj;
            }
            else if (error.name === 'SandboxCreateNotCompleteError') {
                void lifecycle.emit(core_1.SandboxEvents.EVENT_ASYNC_RESULT, undefined);
                process.exitCode = 68;
                return this.latestSandboxProgressObj;
            }
            throw err;
        }
    }
    initSandboxProcessData(prodOrg, sandboxReq) {
        this.sandboxRequestData.alias = this.flags.alias;
        this.sandboxRequestData.setDefault = this.flags['set-default'];
        this.sandboxRequestData.prodOrgUsername = prodOrg.getUsername();
        this.sandboxRequestData.sandboxProcessObject.SandboxName = sandboxReq.SandboxName;
        this.sandboxRequestData.sandboxRequest = sandboxReq;
        this.sandboxRequestData.tracksSource = this.flags['no-track-source'] === true ? false : undefined;
        this.saveSandboxProgressConfig();
    }
    readJsonDefFile() {
        // the -f option
        if (this.flags['definition-file']) {
            this.debug('Reading JSON DefFile %s ', this.flags['definition-file']);
            return JSON.parse(fs.readFileSync(this.flags['definition-file'], 'utf-8'));
        }
    }
    async confirmSandboxReq(sandboxReq) {
        if (this.flags['no-prompt'] || this.jsonEnabled())
            return;
        const columns = {
            key: { header: 'Field' },
            value: { header: 'Value' },
        };
        const data = Object.entries(sandboxReq).map(([key, value]) => ({ key, value }));
        this.styledHeader('Config Sandbox Request');
        this.table(data, columns, {});
        const configurationCorrect = await this.timedPrompt([
            {
                name: 'continue',
                type: 'confirm',
                message: messages.getMessage('isConfigurationOk'),
            },
        ], 10000);
        if (!configurationCorrect.continue) {
            throw messages.createError('error.UserNotSatisfiedWithSandboxConfig');
        }
    }
    validateFlags() {
        if (this.flags['poll-interval'].seconds > this.flags.wait.seconds) {
            throw messages.createError('error.pollIntervalGreaterThanWait', [
                this.flags['poll-interval'].seconds,
                this.flags.wait.seconds,
            ]);
        }
    }
    async getSourceId(prodOrg) {
        if (!this.flags.clone) {
            return undefined;
        }
        try {
            const sourceOrg = await prodOrg.querySandboxProcessBySandboxName(this.flags.clone);
            return sourceOrg.SandboxInfoId;
        }
        catch (err) {
            throw messages.createError('error.noCloneSource', [this.flags.clone], [], err);
        }
    }
}
exports.default = CreateSandbox;
CreateSandbox.summary = messages.getMessage('summary');
CreateSandbox.description = messages.getMessage('description');
CreateSandbox.examples = messages.getMessages('examples');
// eslint-disable-next-line @typescript-eslint/no-explicit-any
CreateSandbox.flags = {
    // needs to change when new flags are available
    'definition-file': sf_plugins_core_1.Flags.file({
        exists: true,
        char: 'f',
        summary: messages.getMessage('flags.definitionFile.summary'),
        description: messages.getMessage('flags.definitionFile.description'),
        exclusive: ['name', 'license-type'],
    }),
    'set-default': sf_plugins_core_1.Flags.boolean({
        char: 's',
        summary: messages.getMessage('flags.setDefault.summary'),
    }),
    alias: sf_plugins_core_1.Flags.string({
        char: 'a',
        summary: messages.getMessage('flags.alias.summary'),
        description: messages.getMessage('flags.alias.description'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
        min: 1,
        unit: 'minutes',
        defaultValue: 30,
        helpValue: '<minutes>',
        exclusive: ['async'],
    }),
    'poll-interval': sf_plugins_core_1.Flags.duration({
        char: 'i',
        summary: messages.getMessage('flags.poll-interval.summary'),
        min: 15,
        unit: 'seconds',
        defaultValue: 30,
        helpValue: '<seconds>',
        exclusive: ['async'],
    }),
    async: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.async.summary'),
        description: messages.getMessage('flags.async.description'),
        exclusive: ['wait', 'poll-interval'],
    }),
    name: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.name.summary'),
        description: messages.getMessage('flags.name.description'),
        exclusive: ['definition-file'],
        parse: (name) => {
            if (name.length > 10) {
                throw messages.createError('error.SandboxNameLength', [name]);
            }
            return Promise.resolve(name);
        },
    }),
    clone: sf_plugins_core_1.Flags.string({
        char: 'c',
        summary: messages.getMessage('flags.clone.summary'),
        description: messages.getMessage('flags.clone.description'),
        exclusive: ['license-type'],
    }),
    'license-type': sf_plugins_core_1.Flags.enum({
        char: 'l',
        summary: messages.getMessage('flags.licenseType.summary'),
        exclusive: ['definition-file', 'clone'],
        options: getLicenseTypes(),
        default: SandboxLicenseType.developer,
    }),
    'target-org': sf_plugins_core_1.Flags.requiredOrg({
        char: 'o',
        summary: messages.getMessage('flags.targetOrg.summary'),
        description: messages.getMessage('flags.targetOrg.description'),
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.noPrompt.summary'),
    }),
    'no-track-source': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.no-track-source.summary'),
        description: messages.getMessage('flags.no-track-source.description'),
        allowNo: false,
    }),
};
CreateSandbox.state = 'beta';
//# sourceMappingURL=sandbox.js.map