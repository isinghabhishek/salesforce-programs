"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployCache = exports.isNotResumable = exports.determineExitCode = exports.poll = exports.cancelDeployAsync = exports.cancelDeploy = exports.executeDeploy = exports.buildComponentSet = exports.resolveApi = exports.validateTests = void 0;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const source_tracking_1 = require("@salesforce/source-tracking");
const configMeta_1 = require("../configMeta");
const project_1 = require("./project");
const types_1 = require("./types");
const errorCodes_1 = require("./errorCodes");
core_1.Messages.importMessagesDirectory(__dirname);
const cacheMessages = core_1.Messages.load('@salesforce/plugin-deploy-retrieve', 'cache', [
    'error.NoRecentJobId',
    'error.InvalidJobId',
]);
const deployMessages = core_1.Messages.load('@salesforce/plugin-deploy-retrieve', 'deploy.metadata', [
    'error.nothingToDeploy',
    'error.nothingToDeploy.Actions',
]);
function validateTests(testLevel, tests) {
    if (testLevel === types_1.TestLevel.RunSpecifiedTests && (tests ?? []).length === 0)
        return false;
    return true;
}
exports.validateTests = validateTests;
async function resolveApi() {
    const agg = await core_1.ConfigAggregator.create({ customConfigMeta: configMeta_1.default });
    const restDeployConfig = agg.getInfo(configMeta_1.ConfigVars.ORG_METADATA_REST_DEPLOY)?.value;
    return restDeployConfig === 'true' ? types_1.API.REST : types_1.API.SOAP;
}
exports.resolveApi = resolveApi;
async function buildComponentSet(opts, stl) {
    // if you specify nothing, you'll get the changes, like sfdx push, as long as there's an stl
    if (!opts['source-dir'] && !opts.manifest && !opts.metadata && stl) {
        /** localChangesAsComponentSet returned an array to support multiple sequential deploys.
         * `sf` chooses not to support this so we force one ComponentSet
         */
        const cs = (await stl.localChangesAsComponentSet(false))?.[0] ?? new source_deploy_retrieve_1.ComponentSet();
        // stl produces a cs with api version already set.  command might have specified a version.
        if (opts['api-version']) {
            cs.apiVersion = opts['api-version'];
            cs.sourceApiVersion = opts['api-version'];
        }
        return cs;
    }
    return source_deploy_retrieve_1.ComponentSetBuilder.build({
        apiversion: opts['api-version'],
        sourceapiversion: await (0, project_1.getSourceApiVersion)(),
        sourcepath: opts['source-dir'],
        manifest: opts.manifest && {
            manifestPath: opts.manifest,
            directoryPaths: await (0, project_1.getPackageDirs)(),
        },
        metadata: opts.metadata && {
            metadataEntries: opts.metadata,
            directoryPaths: await (0, project_1.getPackageDirs)(),
        },
    });
}
exports.buildComponentSet = buildComponentSet;
async function executeDeploy(opts, project, id) {
    project ?? (project = await core_1.SfProject.resolve());
    const apiOptions = {
        checkOnly: opts['dry-run'] || false,
        ignoreWarnings: opts['ignore-warnings'] || false,
        rest: opts.api === types_1.API.REST,
        rollbackOnError: !opts['ignore-errors'] || false,
        runTests: opts.tests || [],
        testLevel: opts['test-level'],
    };
    let deploy;
    let componentSet;
    const org = await core_1.Org.create({ aliasOrUsername: opts['target-org'] });
    const usernameOrConnection = org.getConnection();
    // instantiate source tracking
    // stl will decide, based on the org's properties, what needs to be done
    const stl = await source_tracking_1.SourceTracking.create({
        org,
        project,
        subscribeSDREvents: true,
        ignoreConflicts: opts['ignore-conflicts'],
    });
    if (opts['metadata-dir']) {
        if (id) {
            deploy = new source_deploy_retrieve_1.MetadataApiDeploy({ id, usernameOrConnection });
        }
        else {
            const key = opts['metadata-dir'].type === 'directory' ? 'mdapiPath' : 'zipPath';
            deploy = new source_deploy_retrieve_1.MetadataApiDeploy({
                [key]: opts['metadata-dir'].path,
                usernameOrConnection,
                apiOptions: { ...apiOptions, singlePackage: opts['single-package'] || false },
            });
            await deploy.start();
        }
    }
    else {
        componentSet = await buildComponentSet(opts, stl);
        if (componentSet.size === 0) {
            throw new core_1.SfError(deployMessages.getMessage('error.nothingToDeploy'), 'NothingToDeploy', deployMessages.getMessages('error.nothingToDeploy.Actions'));
        }
        deploy = id
            ? new source_deploy_retrieve_1.MetadataApiDeploy({ id, usernameOrConnection, components: componentSet })
            : await componentSet.deploy({
                usernameOrConnection,
                apiOptions,
            });
    }
    await DeployCache.set(deploy.id, { ...opts, wait: opts.wait?.minutes ?? 33 });
    return { deploy, componentSet };
}
exports.executeDeploy = executeDeploy;
async function cancelDeploy(opts, id) {
    const org = await core_1.Org.create({ aliasOrUsername: opts['target-org'] });
    const deploy = new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection: org.getUsername(), id });
    const componentSet = await buildComponentSet({ ...opts });
    await DeployCache.set(deploy.id, { ...opts, wait: opts.wait?.minutes ?? 33 });
    await deploy.cancel();
    return poll(org, deploy.id, opts.wait, componentSet);
}
exports.cancelDeploy = cancelDeploy;
async function cancelDeployAsync(opts, id) {
    const org = await core_1.Org.create({ aliasOrUsername: opts['target-org'] });
    const deploy = new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection: org.getUsername(), id });
    await deploy.cancel();
    return { id: deploy.id };
}
exports.cancelDeployAsync = cancelDeployAsync;
async function poll(org, id, wait, componentSet) {
    const report = async () => {
        const res = await org.getConnection().metadata.checkDeployStatus(id, true);
        const deployStatus = res;
        return new source_deploy_retrieve_1.DeployResult(deployStatus, componentSet);
    };
    const opts = {
        frequency: kit_1.Duration.milliseconds(1000),
        timeout: wait,
        poll: async () => {
            const deployResult = await report();
            return {
                completed: deployResult.response.done,
                payload: deployResult,
            };
        },
    };
    const pollingClient = await core_1.PollingClient.create(opts);
    return pollingClient.subscribe();
}
exports.poll = poll;
function determineExitCode(result, async = false) {
    if (async) {
        return result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded ? 0 : 1;
    }
    return errorCodes_1.DEPLOY_STATUS_CODES.get(result.response.status);
}
exports.determineExitCode = determineExitCode;
function isNotResumable(status) {
    return [
        source_deploy_retrieve_1.RequestStatus.Succeeded,
        source_deploy_retrieve_1.RequestStatus.Failed,
        source_deploy_retrieve_1.RequestStatus.SucceededPartial,
        source_deploy_retrieve_1.RequestStatus.Canceled,
    ].includes(status);
}
exports.isNotResumable = isNotResumable;
class DeployCache extends core_1.TTLConfig {
    static getFileName() {
        return 'deploy-cache.json';
    }
    static getDefaultOptions() {
        return {
            isGlobal: false,
            isState: true,
            filename: DeployCache.getFileName(),
            stateFolder: core_1.Global.SF_STATE_FOLDER,
            ttl: kit_1.Duration.days(3),
        };
    }
    static async set(key, value) {
        const cache = await DeployCache.create();
        cache.set(key, value);
        await cache.write();
    }
    static async unset(key) {
        const cache = await DeployCache.create();
        cache.unset(key);
        await cache.write();
    }
    static async update(key, obj) {
        const cache = await DeployCache.create();
        cache.update(key, obj);
        await cache.write();
    }
    resolveLatest(useMostRecent, key, throwOnNotFound = true) {
        const jobId = this.resolveLongId(useMostRecent ? this.getLatestKey() : key);
        if (!jobId && useMostRecent)
            throw cacheMessages.createError('error.NoRecentJobId');
        if (throwOnNotFound && !this.has(jobId)) {
            throw cacheMessages.createError('error.InvalidJobId', [jobId]);
        }
        return jobId;
    }
    resolveLongId(jobId) {
        if (jobId.length === 18) {
            return jobId;
        }
        else if (jobId.length === 15) {
            return this.keys().find((k) => k.startsWith(jobId));
        }
        else {
            throw cacheMessages.createError('error.InvalidJobId', [jobId]);
        }
    }
    get(jobId) {
        return super.get(this.resolveLongId(jobId));
    }
}
exports.DeployCache = DeployCache;
//# sourceMappingURL=deploy.js.map