"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataRetrieveResultFormatter = exports.RetrieveResultFormatter = exports.AsyncDeployCancelResultFormatter = exports.DeployCancelResultFormatter = exports.AsyncDeployResultFormatter = exports.DeployReportResultFormatter = exports.DeployResultFormatter = exports.getVersionMessage = exports.toArray = exports.sortTestResults = exports.sortFileResponses = exports.asRelativePaths = void 0;
const os = require("os");
const path = require("path");
const core_1 = require("@oclif/core");
const chalk_1 = require("chalk");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_2 = require("@salesforce/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const types_1 = require("./types");
core_2.Messages.importMessagesDirectory(__dirname);
const deployAsyncMessages = core_2.Messages.load('@salesforce/plugin-deploy-retrieve', 'deploy.async', [
    'info.AsyncDeployResume',
    'info.AsyncDeployStatus',
    'info.AsyncDeployCancel',
    'info.AsyncDeployQueued',
    'info.AsyncDeployCancelQueued',
]);
const retrieveMessages = core_2.Messages.load('@salesforce/plugin-deploy-retrieve', 'retrieve.metadata', [
    'info.WroteZipFile',
    'info.ExtractedZipFile',
]);
function tableHeader(message) {
    return (0, chalk_1.blue)((0, chalk_1.bold)(message));
}
function error(message) {
    return sf_plugins_core_1.StandardColors.error((0, chalk_1.bold)(message));
}
function success(message) {
    return sf_plugins_core_1.StandardColors.success((0, chalk_1.bold)(message));
}
function table(responses, columns, options) {
    // Interfaces cannot be casted to Record<string, unknown> so we have to cast to unknown first
    // See https://github.com/microsoft/TypeScript/issues/15300
    core_1.CliUx.ux.table(responses, columns, options ?? {});
}
function colorStatus(status) {
    if (status === source_deploy_retrieve_1.RequestStatus.Succeeded)
        return sf_plugins_core_1.StandardColors.success(status);
    if (status === source_deploy_retrieve_1.RequestStatus.Failed)
        return sf_plugins_core_1.StandardColors.error(status);
    else
        return sf_plugins_core_1.StandardColors.warning(status);
}
const check = sf_plugins_core_1.StandardColors.success('✓');
function asRelativePaths(fileResponses) {
    const relative = fileResponses.map((file) => {
        return file.filePath ? { ...file, filePath: path.relative(process.cwd(), file.filePath) } : file;
    });
    return relative;
}
exports.asRelativePaths = asRelativePaths;
/**
 * Sorts file responds by type, then by filePath, then by fullName
 */
function sortFileResponses(fileResponses) {
    return fileResponses.sort((i, j) => {
        if (i.type === j.type && i.filePath && j.filePath) {
            if (i.filePath === j.filePath) {
                return i.fullName > j.fullName ? 1 : -1;
            }
            return i?.filePath > j?.filePath ? 1 : -1;
        }
        return i.type > j.type ? 1 : -1;
    });
}
exports.sortFileResponses = sortFileResponses;
function sortTestResults(results = []) {
    return results.sort((a, b) => {
        if (a.methodName === b.methodName) {
            return a.name.localeCompare(b.name);
        }
        return a.methodName.localeCompare(b.methodName);
    });
}
exports.sortTestResults = sortTestResults;
function toArray(entryOrArray) {
    if (entryOrArray) {
        return Array.isArray(entryOrArray) ? entryOrArray : [entryOrArray];
    }
    return [];
}
exports.toArray = toArray;
function getVersionMessage(action, componentSet, api) {
    // commands pass in the.componentSet, which may not exist in some tests or mdapi deploys
    if (!componentSet) {
        return `*** ${action} with ${api} ***`;
    }
    // neither
    if (!componentSet.sourceApiVersion && !componentSet.apiVersion) {
        return `*** ${action} with ${api} ***`;
    }
    // either OR both match (SDR will use either)
    if (!componentSet.sourceApiVersion ||
        !componentSet.apiVersion ||
        componentSet.sourceApiVersion === componentSet.apiVersion) {
        return `*** ${action} with ${api} API v${componentSet.apiVersion ?? componentSet.sourceApiVersion} ***`;
    }
    // has both but they don't match
    return `*** ${action} v${componentSet.sourceApiVersion} metadata with ${api} API v${componentSet.apiVersion} connection ***`;
}
exports.getVersionMessage = getVersionMessage;
class DeployResultFormatter {
    constructor(result, flags) {
        this.result = result;
        this.flags = flags;
        this.absoluteFiles = sortFileResponses(this.result.getFileResponses() ?? []);
        this.relativeFiles = asRelativePaths(this.absoluteFiles);
        this.testLevel = this.flags['test-level'] || types_1.TestLevel.NoTestRun;
        this.verbosity = this.determineVerbosity();
    }
    getJson() {
        if (this.verbosity === 'concise') {
            return {
                ...this.result.response,
                details: {
                    componentFailures: this.result.response.details.componentFailures,
                    runTestResult: this.result.response.details.runTestResult,
                },
                files: this.absoluteFiles.filter((f) => f.state === 'Failed'),
            };
        }
        else {
            return { ...this.result.response, files: this.absoluteFiles };
        }
    }
    display() {
        if (this.verbosity !== 'concise') {
            this.displaySuccesses();
        }
        this.displayFailures();
        this.displayDeletes();
        this.displayTestResults();
    }
    displaySuccesses() {
        const successes = this.relativeFiles.filter((f) => f.state !== 'Failed');
        if (!successes.length || this.result.response.status === source_deploy_retrieve_1.RequestStatus.Failed)
            return;
        const columns = {
            state: { header: 'State' },
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const title = 'Deployed Source';
        const options = { title: tableHeader(title) };
        core_1.CliUx.ux.log();
        table(successes, columns, options);
    }
    displayFailures() {
        if (this.result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded)
            return;
        const failures = this.relativeFiles.filter((f) => f.state === 'Failed');
        if (!failures.length)
            return;
        const columns = {
            problemType: { header: 'Type' },
            fullName: { header: 'Name' },
            error: { header: 'Problem' },
        };
        const options = { title: error(`Component Failures [${failures.length}]`) };
        core_1.CliUx.ux.log();
        table(failures, columns, options);
    }
    displayDeletes() {
        const deletions = this.relativeFiles.filter((f) => f.state === 'Deleted');
        if (!deletions.length)
            return;
        const columns = {
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const options = { title: tableHeader('Deleted Source') };
        core_1.CliUx.ux.log();
        table(deletions, columns, options);
    }
    displayTestResults() {
        if (this.testLevel === types_1.TestLevel.NoTestRun) {
            core_1.CliUx.ux.log();
            return;
        }
        this.displayVerboseTestFailures();
        if (this.verbosity === 'verbose') {
            this.displayVerboseTestSuccesses();
            this.displayVerboseTestCoverage();
        }
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.log(tableHeader('Test Results Summary'));
        const passing = this.result.response.numberTestsCompleted ?? 0;
        const failing = this.result.response.numberTestErrors ?? 0;
        const total = this.result.response.numberTestsTotal ?? 0;
        const time = this.result.response.details.runTestResult.totalTime ?? 0;
        core_1.CliUx.ux.log(`Passing: ${passing}`);
        core_1.CliUx.ux.log(`Failing: ${failing}`);
        core_1.CliUx.ux.log(`Total: ${total}`);
        if (time)
            core_1.CliUx.ux.log(`Time: ${time}`);
    }
    displayVerboseTestSuccesses() {
        const successes = toArray(this.result.response.details.runTestResult?.successes);
        if (successes.length > 0) {
            const testSuccesses = sortTestResults(successes);
            core_1.CliUx.ux.log();
            core_1.CliUx.ux.log(success(`Test Success [${successes.length}]`));
            for (const test of testSuccesses) {
                const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
                core_1.CliUx.ux.log(`${check} ${testName}`);
            }
        }
    }
    displayVerboseTestFailures() {
        if (!this.result.response.numberTestErrors)
            return;
        const failures = toArray(this.result.response.details.runTestResult?.failures);
        const failureCount = this.result.response.details.runTestResult?.numFailures;
        const testFailures = sortTestResults(failures);
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.log(error(`Test Failures [${failureCount}]`));
        for (const test of testFailures) {
            const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
            const stackTrace = test.stackTrace.replace(/\n/g, `${os.EOL}    `);
            core_1.CliUx.ux.log(`• ${testName}`);
            core_1.CliUx.ux.log(`  ${(0, chalk_1.dim)('message')}: ${test.message}`);
            core_1.CliUx.ux.log(`  ${(0, chalk_1.dim)('stacktrace')}: ${os.EOL}    ${stackTrace}`);
            core_1.CliUx.ux.log();
        }
    }
    displayVerboseTestCoverage() {
        const codeCoverage = toArray(this.result.response.details.runTestResult?.codeCoverage);
        if (codeCoverage.length) {
            const coverage = codeCoverage.sort((a, b) => {
                return a.name.toUpperCase() > b.name.toUpperCase() ? 1 : -1;
            });
            core_1.CliUx.ux.log();
            core_1.CliUx.ux.log(tableHeader('Apex Code Coverage'));
            coverage.forEach((cov) => {
                const numLocationsNum = parseInt(cov.numLocations, 10);
                const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
                const color = numLocationsNotCovered > 0 ? sf_plugins_core_1.StandardColors.error : sf_plugins_core_1.StandardColors.success;
                let pctCovered = 100;
                const coverageDecimal = parseFloat(((numLocationsNum - numLocationsNotCovered) / numLocationsNum).toFixed(2));
                if (numLocationsNum > 0) {
                    pctCovered = coverageDecimal * 100;
                }
                cov.numLocations = color(`${pctCovered}%`);
                if (!cov.locationsNotCovered) {
                    cov.lineNotCovered = '';
                }
                const locations = toArray(cov.locationsNotCovered);
                cov.lineNotCovered = locations.map((location) => location.line).join(',');
            });
            table(coverage, {
                name: { header: 'Name' },
                numLocations: { header: '% Covered' },
                lineNotCovered: { header: 'Uncovered Lines' },
            });
        }
    }
    determineVerbosity() {
        if (this.flags.verbose)
            return 'verbose';
        if (this.flags.concise)
            return 'concise';
        return 'normal';
    }
}
exports.DeployResultFormatter = DeployResultFormatter;
class DeployReportResultFormatter extends DeployResultFormatter {
    display() {
        core_1.CliUx.ux.log(`${this.result.response.id}... ${this.result.response.status}`);
        const response = Object.entries(this.result.response).reduce((result, [key, value]) => {
            if (['number', 'boolean', 'string'].includes(typeof value)) {
                if (key === 'status') {
                    return result.concat({ key, value: colorStatus(value) });
                }
                else {
                    return result.concat({ key, value: value });
                }
            }
            return result;
        }, []);
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.table(response, { key: {}, value: {} }, { title: tableHeader('Deploy Info') });
        const opts = Object.entries(this.flags).reduce((result, [key, value]) => {
            if (key === 'timestamp')
                return result;
            return result.concat({ key, value });
        }, []);
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.table(opts, { key: {}, value: {} }, { title: tableHeader('Deploy Options') });
        super.display();
    }
}
exports.DeployReportResultFormatter = DeployReportResultFormatter;
class AsyncDeployResultFormatter {
    constructor(id) {
        this.id = id;
    }
    getJson() {
        return { id: this.id, done: false, status: 'Queued', files: [] };
    }
    display() {
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployQueued'));
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployResume', [this.id]));
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployStatus', [this.id]));
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployCancel', [this.id]));
    }
}
exports.AsyncDeployResultFormatter = AsyncDeployResultFormatter;
class DeployCancelResultFormatter {
    constructor(result) {
        this.result = result;
    }
    getJson() {
        return { ...this.result.response, files: this.result.getFileResponses() ?? [] };
    }
    display() {
        if (this.result.response.status === source_deploy_retrieve_1.RequestStatus.Canceled) {
            core_1.CliUx.ux.log(`Successfully canceled ${this.result.response.id}`);
        }
        else {
            core_1.CliUx.ux.error(`Could not cancel ${this.result.response.id}`);
        }
    }
}
exports.DeployCancelResultFormatter = DeployCancelResultFormatter;
class AsyncDeployCancelResultFormatter {
    constructor(id) {
        this.id = id;
    }
    getJson() {
        return { id: this.id, done: false, status: 'Queued', files: [] };
    }
    display() {
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployCancelQueued'));
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployResume', [this.id]));
        core_1.CliUx.ux.log(deployAsyncMessages.getMessage('info.AsyncDeployStatus', [this.id]));
    }
}
exports.AsyncDeployCancelResultFormatter = AsyncDeployCancelResultFormatter;
class RetrieveResultFormatter {
    constructor(result, packageNames = [], deleteResponses = []) {
        this.result = result;
        this.packageNames = packageNames;
        this.files = sortFileResponses(asRelativePaths((this.result.getFileResponses() ?? []).concat(deleteResponses)));
    }
    getJson() {
        return { ...this.result.response, files: this.files };
    }
    async display() {
        this.displaySuccesses();
        await this.displayPackages();
    }
    displaySuccesses() {
        const successes = this.files.filter((f) => f.state !== 'Failed');
        if (!successes.length)
            return;
        const columns = {
            state: { header: 'State' },
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const title = 'Retrieved Source';
        const options = { title: tableHeader(title) };
        core_1.CliUx.ux.log();
        table(successes, columns, options);
    }
    async displayPackages() {
        const packages = await this.getPackages();
        if (packages?.length) {
            const columns = {
                name: { header: 'Package Name' },
                fullPath: { header: 'Converted Location' },
            };
            const title = 'Retrieved Packages';
            const options = { title: tableHeader(title) };
            core_1.CliUx.ux.log();
            table(packages, columns, options);
        }
    }
    async getPackages() {
        const projectPath = await core_2.SfProject.resolveProjectPath();
        return this.packageNames.map((name) => {
            const packagePath = path.join(projectPath, name);
            return { name, path: packagePath, fullPath: path.resolve(packagePath) };
        });
    }
}
exports.RetrieveResultFormatter = RetrieveResultFormatter;
class MetadataRetrieveResultFormatter {
    constructor(result, opts) {
        this.result = result;
        this.opts = opts;
        this.zipFilePath = path.join(opts['target-metadata-dir'], opts['zip-file-name']);
        this.files = sortFileResponses(asRelativePaths(this.result.getFileResponses() ?? []));
    }
    getJson() {
        delete this.result.response.zipFile;
        return { ...this.result.response, zipFilePath: this.zipFilePath, files: this.files };
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async display() {
        core_1.CliUx.ux.log(retrieveMessages.getMessage('info.WroteZipFile', [this.zipFilePath]));
        if (this.opts.unzip) {
            const extractPath = path.join(this.opts['target-metadata-dir'], path.parse(this.opts['zip-file-name']).name);
            core_1.CliUx.ux.log(retrieveMessages.getMessage('info.ExtractedZipFile', [this.zipFilePath, extractPath]));
        }
    }
}
exports.MetadataRetrieveResultFormatter = MetadataRetrieveResultFormatter;
//# sourceMappingURL=output.js.map