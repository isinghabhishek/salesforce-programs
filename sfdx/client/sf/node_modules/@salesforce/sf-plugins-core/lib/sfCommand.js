"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfCommand = exports.StandardColors = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const chalk = require("chalk");
const ux_1 = require("./ux");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/sf-plugins-core', 'messages');
exports.StandardColors = {
    error: chalk.bold.red,
    warning: chalk.bold.yellow,
    info: chalk.dim,
    success: chalk.bold.green,
};
/**
 * A base command that provides convenient access to CLI help
 * output formatting. Extend this command and set specific properties
 * to add help sections to the command's help output.
 *
 * @extends @oclif/core/command
 * @see https://github.com/oclif/core/blob/main/src/command.ts
 */
class SfCommand extends core_1.Command {
    constructor(argv, config) {
        super(argv, config);
        this.warnings = [];
        const outputEnabled = !this.jsonEnabled();
        this.spinner = new ux_1.Spinner(outputEnabled);
        this.progress = new ux_1.Progress(outputEnabled && core_2.envVars.getBoolean(core_2.EnvironmentVariable.SF_USE_PROGRESS_BAR, true));
        this.ux = new ux_1.Ux(outputEnabled);
        this.prompter = new ux_1.Prompter();
        this.lifecycle = core_2.Lifecycle.getInstance();
    }
    get statics() {
        return this.constructor;
    }
    /**
     * Log a success message that has the standard success message color applied
     *
     * @param message
     * @param args
     */
    logSuccess(message) {
        this.log(exports.StandardColors.success(message));
    }
    /**
     * Log warning to users. If --json is enabled, then the warning
     * will be added to the json output under the warnings property.
     */
    warn(input) {
        const colorizedArgs = [];
        this.warnings.push(input);
        const message = typeof input === 'string' ? input : input.message;
        colorizedArgs.push(`${exports.StandardColors.warning(messages.getMessage('warning.prefix'))} ${message}`);
        colorizedArgs.push(...this.formatActions(typeof input === 'string' ? [] : input.actions || [], { actionColor: exports.StandardColors.info }));
        this.log(colorizedArgs.join(os.EOL));
        return input;
    }
    /**
     * Log info message to users.
     */
    info(input) {
        const colorizedArgs = [];
        const message = typeof input === 'string' ? input : input.message;
        colorizedArgs.push(`${exports.StandardColors.info(message)}`);
        colorizedArgs.push(...this.formatActions(typeof input === 'string' ? [] : input.actions || [], { actionColor: exports.StandardColors.info }));
        this.log(colorizedArgs.join(os.EOL));
    }
    /**
     * Warn user about sensitive information (access tokens, etc...) before
     * logging to the console.
     */
    logSensitive(msg) {
        this.warn(messages.getMessage('warning.security'));
        this.log(msg);
    }
    /**
     * Display a table on the console. Will automatically be suppressed when --json flag is present.
     */
    table(data, columns, options) {
        this.ux.table(data, columns, options);
    }
    /**
     * Log a stylized url to the console. Will automatically be suppressed when --json flag is present.
     */
    url(text, uri, params = {}) {
        this.ux.url(text, uri, params);
    }
    /**
     * Log stylized JSON to the console. Will automatically be suppressed when --json flag is present.
     */
    styledJSON(obj) {
        this.ux.styledJSON(obj);
    }
    /**
     * Log stylized object to the console. Will automatically be suppressed when --json flag is present.
     */
    styledObject(obj) {
        this.ux.styledObject(obj);
    }
    /**
     * Log stylized header to the console. Will automatically be suppressed when --json flag is present.
     */
    styledHeader(text) {
        this.ux.styledHeader(text);
    }
    /**
     * Prompt user for information. See https://www.npmjs.com/package/inquirer for more.
     *
     * This will NOT be automatically suppressed when the --json flag is present since we assume
     * that any command that prompts the user for required information will not also support the --json flag.
     *
     * If you need to conditionally suppress prompts to support json output, then do the following:
     *
     * @example
     * if (!this.jsonEnabled()) {
     *   await this.prompt();
     * }
     */
    async prompt(questions, initialAnswers) {
        return this.prompter.prompt(questions, initialAnswers);
    }
    /**
     * Simplified prompt for single-question confirmation.  Times out and throws after 10s
     *
     * @param message text to display.  Do not include a question mark.
     * @param ms milliseconds to wait for user input.  Defaults to 10s.
     * @return true if the user confirms, false if they do not.
     */
    async confirm(message, ms = 10000) {
        const { confirmed } = await this.timedPrompt([
            {
                name: 'confirmed',
                message,
                type: 'confirm',
            },
        ], ms);
        return confirmed;
    }
    /**
     * Prompt user for information with a timeout (in milliseconds). See https://www.npmjs.com/package/inquirer for more.
     */
    async timedPrompt(questions, ms = 10000, initialAnswers) {
        return this.prompter.timedPrompt(questions, ms, initialAnswers);
    }
    async _run() {
        if (this.statics.requiresProject) {
            this.project = await this.assignProject();
        }
        if (this.statics.state === 'beta') {
            this.warn(messages.getMessage('warning.CommandInBeta'));
        }
        this.lifecycle.onWarning(async (warning) => {
            this.warn(warning);
        });
        return super._run();
    }
    /**
     * Wrap the command result into the standardized JSON structure.
     */
    toSuccessJson(result) {
        var _a;
        return {
            status: (_a = process.exitCode) !== null && _a !== void 0 ? _a : 0,
            result,
            warnings: this.warnings,
        };
    }
    /**
     * Wrap the command error into the standardized JSON structure.
     */
    toErrorJson(error) {
        return {
            ...error,
            warnings: this.warnings,
        };
    }
    async assignProject() {
        try {
            return await core_2.SfProject.resolve();
        }
        catch (err) {
            if (err instanceof Error && err.name === 'InvalidProjectWorkspaceError') {
                throw messages.createError('errors.RequiresProject');
            }
            throw err;
        }
    }
    async catch(error) {
        var _a, _b;
        // transform an unknown error into one that conforms to the interface
        const codeFromError = error instanceof core_2.SfError ? error.exitCode : 1;
        (_a = process.exitCode) !== null && _a !== void 0 ? _a : (process.exitCode = codeFromError);
        const sfErrorProperties = error instanceof core_2.SfError
            ? { data: error.data, actions: error.actions, code: codeFromError, context: error.context }
            : {};
        const sfCommandError = {
            ...sfErrorProperties,
            ...{
                message: error.message,
                name: (_b = error.name) !== null && _b !== void 0 ? _b : 'Error',
                status: process.exitCode,
                stack: error.stack,
                exitCode: process.exitCode,
            },
        };
        if (this.jsonEnabled()) {
            core_1.CliUx.ux.styledJSON(this.toErrorJson(sfCommandError));
        }
        else {
            // eslint-disable-next-line no-console
            console.error(this.formatError(sfCommandError));
        }
        return sfCommandError;
    }
    /**
     * Format errors and actions for human consumption. Adds 'Error (<ErrorCode>):',
     * When there are actions, we add 'Try this:' in blue
     * followed by each action in red on its own line.
     * If Error.code is present it is output last in parentheses
     *
     * @returns {string} Returns decorated messages.
     */
    formatError(error) {
        const colorizedArgs = [];
        const errorCode = error.code ? ` (${error.code})` : '';
        const errorPrefix = `${exports.StandardColors.error(messages.getMessage('error.prefix', [errorCode]))}`;
        colorizedArgs.push(`${errorPrefix} ${error.message}`);
        colorizedArgs.push(...this.formatActions(error.actions || []));
        if (error.stack && core_2.envVars.getString(SfCommand.SF_ENV) === core_2.Mode.DEVELOPMENT) {
            colorizedArgs.push(exports.StandardColors.info(`\n*** Internal Diagnostic ***\n\n${error.stack}\n******\n`));
        }
        return colorizedArgs.join('\n');
    }
    /**
     * Utility function to format actions lines
     *
     * @param actions
     * @param options
     * @private
     */
    formatActions(actions, options = { actionColor: exports.StandardColors.info }) {
        const colorizedArgs = [];
        // Format any actions.
        if (actions === null || actions === void 0 ? void 0 : actions.length) {
            colorizedArgs.push(`\n${exports.StandardColors.info(messages.getMessage('actions.tryThis'))}\n`);
            actions.forEach((action) => {
                colorizedArgs.push(`${options.actionColor(action)}`);
            });
        }
        return colorizedArgs;
    }
}
exports.SfCommand = SfCommand;
SfCommand.SF_ENV = 'SF_ENV';
SfCommand.enableJsonFlag = true;
SfCommand.tableFlags = core_1.CliUx.ux.table.flags;
//# sourceMappingURL=sfCommand.js.map