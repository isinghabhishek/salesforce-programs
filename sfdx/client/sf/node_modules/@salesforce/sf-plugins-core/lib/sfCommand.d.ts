import { CliUx, Command, Config, HelpSection, Interfaces } from '@oclif/core';
import { SfProject, StructuredMessage, SfError } from '@salesforce/core';
import { AnyJson } from '@salesforce/ts-types';
import * as chalk from 'chalk';
import { Progress, Prompter, Spinner, Ux } from './ux';
export interface SfCommandInterface extends Interfaces.Command {
    configurationVariablesSection?: HelpSection;
    envVariablesSection?: HelpSection;
    errorCodes?: HelpSection;
}
export declare const StandardColors: {
    error: chalk.Chalk;
    warning: chalk.Chalk;
    info: chalk.Chalk;
    success: chalk.Chalk;
};
/**
 * A base command that provides convenient access to CLI help
 * output formatting. Extend this command and set specific properties
 * to add help sections to the command's help output.
 *
 * @extends @oclif/core/command
 * @see https://github.com/oclif/core/blob/main/src/command.ts
 */
export declare abstract class SfCommand<T> extends Command {
    static SF_ENV: string;
    static enableJsonFlag: boolean;
    static configurationVariablesSection?: HelpSection;
    static envVariablesSection?: HelpSection;
    static errorCodes?: HelpSection;
    static tableFlags: typeof CliUx.Table.table.flags;
    static requiresProject: boolean;
    spinner: Spinner;
    progress: Progress;
    project: SfProject;
    private warnings;
    private ux;
    private prompter;
    private lifecycle;
    protected get statics(): typeof SfCommand;
    constructor(argv: string[], config: Config);
    /**
     * Log a success message that has the standard success message color applied
     *
     * @param message
     * @param args
     */
    logSuccess(message: string): void;
    /**
     * Log warning to users. If --json is enabled, then the warning
     * will be added to the json output under the warnings property.
     */
    warn(input: SfCommand.Warning): SfCommand.Warning;
    /**
     * Log info message to users.
     */
    info(input: SfCommand.Info): void;
    /**
     * Warn user about sensitive information (access tokens, etc...) before
     * logging to the console.
     */
    logSensitive(msg?: string): void;
    /**
     * Display a table on the console. Will automatically be suppressed when --json flag is present.
     */
    table<R extends Ux.Table.Data>(data: R[], columns: Ux.Table.Columns<R>, options?: Ux.Table.Options): void;
    /**
     * Log a stylized url to the console. Will automatically be suppressed when --json flag is present.
     */
    url(text: string, uri: string, params?: {}): void;
    /**
     * Log stylized JSON to the console. Will automatically be suppressed when --json flag is present.
     */
    styledJSON(obj: AnyJson): void;
    /**
     * Log stylized object to the console. Will automatically be suppressed when --json flag is present.
     */
    styledObject(obj: AnyJson): void;
    /**
     * Log stylized header to the console. Will automatically be suppressed when --json flag is present.
     */
    styledHeader(text: string): void;
    /**
     * Prompt user for information. See https://www.npmjs.com/package/inquirer for more.
     *
     * This will NOT be automatically suppressed when the --json flag is present since we assume
     * that any command that prompts the user for required information will not also support the --json flag.
     *
     * If you need to conditionally suppress prompts to support json output, then do the following:
     *
     * @example
     * if (!this.jsonEnabled()) {
     *   await this.prompt();
     * }
     */
    prompt<R = Prompter.Answers>(questions: Prompter.Questions<R>, initialAnswers?: Partial<R>): Promise<R>;
    /**
     * Simplified prompt for single-question confirmation.  Times out and throws after 10s
     *
     * @param message text to display.  Do not include a question mark.
     * @param ms milliseconds to wait for user input.  Defaults to 10s.
     * @return true if the user confirms, false if they do not.
     */
    confirm(message: string, ms?: number): Promise<boolean>;
    /**
     * Prompt user for information with a timeout (in milliseconds). See https://www.npmjs.com/package/inquirer for more.
     */
    timedPrompt<R = Prompter.Answers>(questions: Prompter.Questions<R>, ms?: number, initialAnswers?: Partial<R>): Promise<R>;
    _run<R>(): Promise<R | undefined>;
    /**
     * Wrap the command result into the standardized JSON structure.
     */
    protected toSuccessJson(result: T): SfCommand.Json<T>;
    /**
     * Wrap the command error into the standardized JSON structure.
     */
    protected toErrorJson(error: SfCommand.Error): SfCommand.Error;
    protected assignProject(): Promise<SfProject>;
    protected catch(error: Error | SfError | SfCommand.Error): Promise<SfCommand.Error>;
    /**
     * Format errors and actions for human consumption. Adds 'Error (<ErrorCode>):',
     * When there are actions, we add 'Try this:' in blue
     * followed by each action in red on its own line.
     * If Error.code is present it is output last in parentheses
     *
     * @returns {string} Returns decorated messages.
     */
    protected formatError(error: SfCommand.Error): string;
    /**
     * Utility function to format actions lines
     *
     * @param actions
     * @param options
     * @private
     */
    private formatActions;
    abstract run(): Promise<T>;
}
export declare namespace SfCommand {
    type Info = StructuredMessage | string;
    type Warning = StructuredMessage | string;
    interface Json<T> {
        status: number;
        result: T;
        warnings?: Warning[];
    }
    interface Error {
        status: number;
        name: string;
        message: string;
        stack: string | undefined;
        warnings?: Warning[];
        actions?: string[];
        code?: unknown;
        exitCode?: number;
        data?: unknown;
        context?: string;
    }
}
//# sourceMappingURL=sfCommand.d.ts.map