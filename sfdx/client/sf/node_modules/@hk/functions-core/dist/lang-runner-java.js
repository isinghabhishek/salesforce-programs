"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const fs = require("fs");
const https = require("https");
const crypto = require("crypto");
const execa = require("execa");
const semver = require("semver");
const lang_runner_1 = require("./lang-runner");
const runtimeJarVersion = '1.0.7';
const runtimeJarName = `sf-fx-runtime-java-runtime-${runtimeJarVersion}-jar-with-dependencies.jar`;
const runtimeJarUrl = `https://repo1.maven.org/maven2/com/salesforce/functions/sf-fx-runtime-java-runtime/${runtimeJarVersion}/${runtimeJarName}`;
const runtimeJarDir = path.resolve(os.tmpdir(), 'sf-fx-runtime-java');
const runtimeJarPath = path.resolve(runtimeJarDir, `sf-fx-runtime-java-${runtimeJarVersion}.jar`);
const runtimeJarSha = '91b1c8c2b42dfbda6147ea32f114ae44e496a0577af7f19e31b51e619cb2962b';
class LangRunnerJava extends lang_runner_1.default {
    detect() {
        return __awaiter(this, void 0, void 0, function* () {
            const pomXmlPath = path.resolve(this.path, 'pom.xml');
            try {
                yield fs.promises.access(pomXmlPath);
            }
            catch (_a) {
                return false;
            }
            return true;
        });
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkJava();
            yield this.ensureRuntimeJar();
            yield this.runMavenCompile();
        });
    }
    start() {
        return this.runRuntimeJarServe();
    }
    checkJava() {
        return __awaiter(this, void 0, void 0, function* () {
            let stderr = '';
            try {
                ({ stderr } = yield execa.command('java -fullversion'));
            }
            catch (error) {
                throw new Error('Java executable not found.');
            }
            stderr = stderr.trim();
            const re = /"(\d+.\d+.\d+).*"/;
            const matches = re.exec(stderr);
            if (!matches || matches.length < 2) {
                throw new Error(`Could not determine Java version from: ${stderr}`);
            }
            this.javaVersion = matches[1];
        });
    }
    ensureRuntimeJar() {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield LangRunnerJava.checkRuntimeJar()) {
                return;
            }
            yield this.downloadRuntimeJar();
        });
    }
    runMavenCompile() {
        return __awaiter(this, void 0, void 0, function* () {
            let mvnBin = path.resolve(this.path, 'mvnw');
            try {
                // check to see if `mvnw` exists in function root.
                yield fs.promises.access(mvnBin);
            }
            catch (_a) {
                // mvnw does not exist, use user installed `mvn` instead.
                mvnBin = 'mvn';
            }
            try {
                // ensure mvn or mvnw exists and is executable
                yield execa.command(`${mvnBin} --version`, { cwd: this.path });
            }
            catch (error) {
                throw new Error(`Could not run maven executable: ${error}`);
            }
            try {
                yield execa.command(`${mvnBin} compile`, { stdio: 'inherit', cwd: this.path });
            }
            catch (error) {
                throw new Error(`Could not compile function with maven: ${error}`);
            }
        });
    }
    static checkRuntimeJar() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield fs.promises.access(runtimeJarPath);
            }
            catch (_a) {
                return false;
            }
            return true;
        });
    }
    downloadRuntimeJar() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield LangRunnerJava.ensureDirExists(runtimeJarDir);
                yield this.downloadToFile(runtimeJarUrl, runtimeJarPath);
                yield LangRunnerJava.verifyFileSha(runtimeJarPath, runtimeJarSha);
            }
            catch (err) {
                try {
                    yield fs.promises.unlink(runtimeJarPath);
                }
                catch (_a) {
                    // failed to delete the jar -- probably never created it.
                }
                throw err;
            }
        });
    }
    runRuntimeJarServe() {
        let agentLibArg = '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=';
        if (this.javaVersion && semver.satisfies(this.javaVersion, '1.8.*')) {
            agentLibArg = agentLibArg + this.debugPort;
        }
        else {
            agentLibArg = agentLibArg + `*:${this.debugPort}`;
        }
        return execa.command(`java ${agentLibArg} -jar ${runtimeJarPath} serve --host=${this.host} --port=${this.port} ${this.path}`, {
            cwd: this.path,
            stdio: 'inherit',
        });
    }
    downloadToFile(url, path) {
        return new Promise((resolve, reject) => {
            const file = fs.createWriteStream(path);
            https
                .get(url, (resp) => {
                if (resp.statusCode !== 200) {
                    reject(`Unexpected status code: ${resp.statusCode}`);
                    return;
                }
                resp.pipe(file);
                file.on('finish', resolve);
                file.on('error', reject);
            })
                .on('error', (err) => {
                reject(err);
            });
        });
    }
    static verifyFileSha(path, expectedDigest) {
        return __awaiter(this, void 0, void 0, function* () {
            const shaHash = crypto.createHash('sha256');
            const fileBuf = yield fs.promises.readFile(path);
            shaHash.update(fileBuf);
            const actualDigest = shaHash.digest('hex');
            if (expectedDigest !== actualDigest) {
                throw new Error(`${path} could not be validated.`);
            }
        });
    }
    static ensureDirExists(dir) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield fs.promises.mkdir(dir);
            }
            catch (err) {
                // Don't throw if the dir already existed
                if (err.code !== 'EEXIST') {
                    throw err;
                }
            }
        });
    }
}
exports.default = LangRunnerJava;
